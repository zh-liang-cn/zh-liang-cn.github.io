<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>周亮的博客</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="周亮的博客"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="周亮的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="周亮的博客">周亮的博客</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/zh-liang-cn/" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2012/09/27/vim-upcase-downcase/">VIM字符大小写转换</a></h2><div class="post-info"><a></a>2012-09-27</div><div class="post-content">VIM提供了字符大小写转换的快捷键，在coding的时候会感觉很贴心，当然，前提是记住他们。
</div><a class="read-more" href="/2012/09/27/vim-upcase-downcase/">&hellip; more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2012/09/11/javascript-date/">JavaScript Date</a></h2><div class="post-info"><a></a>2012-09-11</div><div class="post-content">今天工作中遇到JavaScript的Date计算和格式化的问题，顺便整理了一下JavaScript中的Date的相关API，试做简单记录，代码均在<a href=\"http://nodejs.org/\">Node.js</a>上测试通过。
</div><a class="read-more" href="/2012/09/11/javascript-date/">&hellip; more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2012/08/01/rails-rack/">[Rails代码解读]Rack在Rails中的使用</a></h2><div class="post-info"><a></a>2012-08-01</div><div class="post-content">今天工作中遇到Rails的一个问题，最后发现是使用的一个叫Rack包版本不兼容Rails2.3引起的，虽然问题很容易就解决了，但是Rack这个包是干什么的却引发了我的兴趣，经过查资料阅读代码，写了这篇博客。Rack是一个中间件，介于Web应用程序和Web服务器之间，为所有的Web服务器都提供了统一的接口，使用Rack构建的Web应用程序能简单换到其他的Web服务器上，因为Rails在底层用到了Rack，所以我们可以在开发的时候使用Webrick，然后通过fastcgi或者ruby_mod发布到nginx或者Apache。 </div><a class="read-more" href="/2012/08/01/rails-rack/">&hellip; more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2012/07/23/rails-activesupport-concern/">[Rails代码解读]ActiveSupport::Concern</a></h2><div class="post-info"><a></a>2012-07-23</div><div class="post-content">模块是方法和常量的集合，模块和类一样，其中的可以包括两种方法：实例方法(Instance Method)、模块方法(Module Method)。当一个类混入(Mixin，本文中称混入)一个模块时，模块中的实例方法会成为该类的方法(具体是类的类方法还是实例方法，取决于是include还是extend)。但是模块方法会被忽略，而且，模块方法可以虽然定义在模块中，但是可以直接调用。
</div><a class="read-more" href="/2012/07/23/rails-activesupport-concern/">&hellip; more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2012/07/08/javascript-this/">JavaScript中的this</a></h2><div class="post-info"><a></a>2012-07-08</div><div class="post-content">JavaScript是一门极为灵活的语言，其神奇之处在于其面向对象的实现方式和函数。而函数往往又认为是JavaScript中最Amazing（或者翻译为惊艳？）的地方。<a target="_blank" rel="noopener" href="http://www.jquery.com">JQuery</a>这样强大的库正是建立于JavaScript灵活的函数之上的。而要正确的使用JavaScript也必须对对象和函数有更深入的了解，笔者在开发JQuery插件的过程中，遇到了很多疑惑，进而得到了一些关于对象和函数的心得，希望能对读者有用。</div><a class="read-more" href="/2012/07/08/javascript-this/">&hellip; more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2012/06/29/easymock/">用EasyMock进行单元测试：什么是EasyMock</a></h2><div class="post-info"><a></a>2012-06-29</div><div class="post-content">我们都知道单元测试，也常常写单元测试，但是对于什么是单元测试却没有仔细思考过，大概觉得创建一个类继承TestCase，然后写一些assert语句就算是了吧。当然我也常常遇到有人认为在Java类中写main函数也算是单元测试的。总之，归结到一句话，我们可能觉得写了一段代码对我的代码中的一个方法进行了验证，就算是单元测试了。一直到前不久之前，我也算是这大部分人中的一个。由于我之前写SSH比较多，因此我也想当然得认为要测试一个DAO，就必须往数据库里面插入一些数据，然后调用DAO，看能否返回正确的结果这是单元测试。 事实上，我错了。
</div><a class="read-more" href="/2012/06/29/easymock/">&hellip; more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2012/06/28/vim-buffer/">Vim的Buffer/缓冲区</a></h2><div class="post-info"><a></a>2012-06-28</div><div class="post-content">顾名思义，Buffer是内存中的一块缓冲区域，用于临时存放Vim打开过的文件。用Vim打开文件后，文件就自动被加入到Buffer队列中，而且Buffer中永远是最新的版本，修改文件后还未保存时，改动就存在于Buffer中。打开过的文件会一直存在Buffer中，除非手动的删除（bw命令，不过很多时候没这个必要）。在阅读或者编写代码的时候，会经常在多个文件之间跳转，很好的利用Buffer会当然的make
your life more easier。'
</div><a class="read-more" href="/2012/06/28/vim-buffer/">&hellip; more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2012/04/17/mysql-procedure/">用MySQL Procedure同时像级联表插入数据</a></h2><div class="post-info"><a></a>2012-04-17</div><div class="post-content">一个月以来都没写博客，这篇博客的目的是提醒自己继续写下去，顺便记下笔记，看官若无兴趣请直接飘过。级联表是关系数据库存储领域模型（Domain Model）中一对多关系的不二法门，比如“学生”和“班级”，实在是常用得很。创建表时建立外键关联，查询时使用inner join或者多表联合查询非常便捷。不过插入数据则相对麻烦，因为关键关联的缘故，需要先插入主表，然后再插入从表，如果使用auto_increment主键，在插入从表之前必须获取刚刚插入主表时生成的ID。</div><a class="read-more" href="/2012/04/17/mysql-procedure/">&hellip; more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2012/03/05/linux-dif/">Linux上diff命令详解</a></h2><div class="post-info"><a></a>2012-03-05</div><div class="post-content"><a href="http://en.wikipedia.org/wiki/Diff" target="_blank">diff</a>程序是linux上非常重要的工具，用于比较文件的内容，特别是比较两个版本不同的文件(本文中的a.c、b.c可以理解为两个版本的同一个文件，b.c是在a.c的基础上的修正版)以找到改动的地方。diff在命令行中打印每一个行的改动。最新版本的diff还支持二进制文件。diff程序的输出被称为补丁(patch)，因为unix系统中还有一个<a href="http://en.wikipedia.org/wiki/Patch_(Unix)" target="_blank">patch</a>程序，可以根据diff的输出将a.c的文件内容更新为b.c。diff是svn、cvs、git等版本控制工具不可或缺的一部分。</div><a class="read-more" href="/2012/03/05/linux-dif/">&hellip; more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2011/12/15/x-window-system/">X Window System简介</a></h2><div class="post-info"><a></a>2011-12-15</div><div class="post-content">1984年，MIT开始研究X Window System，用于在Unix上支持GUI界面，X Window System研究时是作为应用软件进行开发的，而不是操作系统。而且X Window System是作为架构规范进行研究，因此需要人和组织对其进行实现和包装（和linux一样，要有发行版）。1987年，X版本更新到X11，这一版有非常明显的进步，因此后面X Window System也被称为X11，X11有通过网络功能访问GUI界面的功能。</div><a class="read-more" href="/2011/12/15/x-window-system/">&hellip; more</a></article></li></ul></main><footer><div class="paginator"><a class="prev" href="/page/2/">prev</a><a class="next" href="/page/4/">next</a></div><div class="copyright"><p>&copy; 2012 - 2021 <a href="https://zh-liang-cn.github.io">Liang</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>