<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>周亮的博客</title>
  
  
  <link href="http://zh-liang-cn.github.io/atom.xml" rel="self"/>
  
  <link href="http://zh-liang-cn.github.io/"/>
  <updated>2021-10-30T16:18:49.727Z</updated>
  <id>http://zh-liang-cn.github.io/</id>
  
  <author>
    <name>Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库的事务以及事务隔离级别</title>
    <link href="http://zh-liang-cn.github.io/2020/02/14/isolation-levels-in-database/"/>
    <id>http://zh-liang-cn.github.io/2020/02/14/isolation-levels-in-database/</id>
    <published>2020-02-13T16:01:02.000Z</published>
    <updated>2021-10-30T16:18:49.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么"></a>事务是什么</h2><p>数据库事务是数据库管理系统执行过程中的一个逻辑单位，包含了一个有限的数据库操作序列。事务不是天然存在的东西，它是被人为创造出来，目的是简化应用层的编程模型。数据库事务有两个目的：</p><ul><li>定义一个逻辑单位，以便于当数据库从故障中恢复的时候能正确地恢复数据</li><li>提供一种隔离方式，以便于解决多个客户端并发操作的时候出现的奇怪问题</li></ul><h2 id="ACID是什么"><a href="#ACID是什么" class="headerlink" title="ACID是什么"></a>ACID是什么</h2><p>数据库系统在实现事务的时候必须满足4个条件：</p><table><thead><tr><th>简称</th><th>中文</th><th>说明</th></tr></thead><tbody><tr><td>Atomic</td><td>原子性</td><td>事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</td></tr><tr><td>Consistent</td><td>一致性</td><td>事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束</td></tr><tr><td>Isolated</td><td>隔离性</td><td>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</td></tr><tr><td>Durable</td><td>持久性</td><td>已被提交的事务对数据库的修改应该永久保存在数据库中</td></tr></tbody></table><p>这4个条件构成了常说的ACID模型。数据库系统在实现事务的时候要遵照ACID模型，也就是说数据库事务必须是：</p><ul><li>原子的（它必须完整地完成或不起作用）</li><li>一致的（它必须符合数据库中现有的约束）</li><li>隔离的（它不能影响其他事务）</li><li>持久的（必须将其写入持久性存储）</li></ul><h2 id="事务的隔离级别是什么"><a href="#事务的隔离级别是什么" class="headerlink" title="事务的隔离级别是什么"></a>事务的隔离级别是什么</h2><p>在数据库系统中，隔离度决定了其他用户和系统如何看到事务完整性。较低的隔离级别可提高并发能力，但同时也会导致出现更多的并发问题（例如脏读或丢失更新）；较高的隔离级别可以减少并发问题，但需要更多的系统资源，也会降低系统的并发能力。最高级别的隔离会导致性能低下，无法应对业务需求，因此也很少使用。</p><p>事务的隔离在实现的时候需要兼顾性能和应用层实际需求。针对四种可能出现的问题，定义了四种隔离级别：</p><table><thead><tr><th>Isolation Level</th><th>隔离级别</th><th>脏读</th><th>更新丢失</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>读未提交</td><td><span style="color:red">可能发生</span></td><td><span style="color:red">可能发生</span></td><td><span style="color:red">可能发生</span></td><td><span style="color:red">可能发生</span></td></tr><tr><td>Read Committed</td><td>读已提交</td><td><span style="color:green">不会发生</span></td><td><span style="color:red">可能发生</span></td><td><span style="color:red">可能发生</span></td><td><span style="color:red">可能发生</span></td></tr><tr><td>Repeatable Read</td><td>可重复读</td><td><span style="color:green">不会发生</span></td><td><span style="color:green">不会发生</span></td><td><span style="color:green">不会发生</span></td><td><span style="color:red">可能发生</span></td></tr><tr><td>Serializable</td><td>可串行化</td><td><span style="color:green">不会发生</span></td><td><span style="color:green">不会发生</span></td><td><span style="color:green">不会发生</span></td><td><span style="color:green">不会发生</span></td></tr></tbody></table><p>在四种隔离级别中, Serializable的级别最高, Read Uncommited级别最低。</p><ul><li>大多数数据库的默认隔离级别为: Read Commited,如Sql Server, Oracle。</li><li>少数数据库默认的隔离级别为Repeatable Read, 如MySQL InnoDB存储引擎。</li></ul><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>如下图所示，有 emails 和 mailboxes 两张表，emails 表中 unread_flag 字段表示是否已读，mailboxes 表中 unread 字段则是未读的email数量。</p><p>当用户1执行 insert 操作和 update 操作中间，用户2进行了读取，这时会获得一个矛盾的结果，明明有1封未读的 email，但是 unread 计数器却是0。</p><p><img src="https://zh-liang-cn.oss-cn-hangzhou.aliyuncs.com/images/51EB2AC5-758D-42CD-947E-6CDE8D1A7654_1_105_c.jpeg"></p><p>防止保证：读数据库的时候，只能看到已成功提交的数据。</p><h3 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h3><p>如下图所示，用户1和用户2都分别尝试获取 counter，然后对 counter 进行加1并保存，理论结果应该是44，但是实际上结果为43。</p><p><img src="https://zh-liang-cn.oss-cn-hangzhou.aliyuncs.com/images/077E886C-0AE1-4A76-9B4F-3C7F69A5EB72_1_105_c.jpeg"></p><p>防止保证：通过原子化写操作、加锁等方式。</p><h3 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h3><p>Alice 和 Bob 同时购买一辆车，买车同时也会更新发票，下图的场景中会出现， Bob 买到了车，但是 Alice 收到了发票的情况。</p><p>注意，这种情况和 <strong>丢失更新</strong> 不一样，丢失更新中第二次写入是在第一个事务提交后才执行的。</p><p><img src="https://zh-liang-cn.oss-cn-hangzhou.aliyuncs.com/images/F51A6AD6-9621-44BB-909F-23752F7CC9CD_1_105_c.jpeg"></p><p>防止保证：写数据库的时候，只能覆盖已经成功提交的数据。</p><h3 id="不可重复读（读倾斜）"><a href="#不可重复读（读倾斜）" class="headerlink" title="不可重复读（读倾斜）"></a>不可重复读（读倾斜）</h3><p>Alice有两个子账户，分别有500，一共有1000，转账者从账户2转了100到账户1，转账有两个SQL操作，两个操作在同一个事务中。如果 Alice 在同一个事务中读取了多次账户1，最初读取到了账户1是500，而后面会读取到600，两次读取数据不一致。</p><p><img src="https://zh-liang-cn.oss-cn-hangzhou.aliyuncs.com/images/2070BC05-6770-4BE7-BAA3-5C88761D03C3_1_105_c.jpeg"></p><p>防止保证：读数据库的时候，只能看到已成功提交的数据。</p><h3 id="幻读（写倾斜）"><a href="#幻读（写倾斜）" class="headerlink" title="幻读（写倾斜）"></a>幻读（写倾斜）</h3><p>下图中的表是一个 oncall 排班系统，如果有两个医生 oncall 的情况下，允许一个医生退出 oncall。Alice 和 Bob 分别读取了 oncall 的人数，判断当前 oncall 的人数多于两人，然后分别退出了 oncall，导致这个时间段无人 oncall。</p><p><img src="https://zh-liang-cn.oss-cn-hangzhou.aliyuncs.com/images/76024979-5358-4E84-AE98-6CEB66AB4ECE_1_105_c.jpeg"></p><p>第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时 (此时第一事务还未提交) ，第二个事务向表中插入一行新数据。这时第一个事务再去读取表时,发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p><p>防止保证：如果只有在事务完全提交后才能读取数据，则可以避免该问题。</p><h2 id="事务隔离是如何实现的"><a href="#事务隔离是如何实现的" class="headerlink" title="事务隔离是如何实现的"></a>事务隔离是如何实现的</h2><p>不同的隔离级别采用不同的锁类开来实现。</p><h3 id="可序列化的"><a href="#可序列化的" class="headerlink" title="可序列化的"></a>可序列化的</h3><p>有两种方式：</p><ul><li>使用基于锁的并发控制实现，可串行性要求在事务结束时释放读写锁（在选定数据上获取）。此外，当SELECT查询使用带范围的WHERE子句时，必须获取范围锁，尤其是要避免幻像读取现象。</li><li>当使用基于非锁的并发控制时，不会获取任何锁。但是，如果系统在多个并发事务中检测到写冲突，则仅允许其中之一提交。这种方式称之为快照隔离。</li></ul><h3 id="重复读取"><a href="#重复读取" class="headerlink" title="重复读取"></a>重复读取</h3><p>基于锁的并发控制实现将保持读写锁（在选定数据上获取），直到事务结束为止。但是，范围锁不受管理，因此可能发生幻像读取。</p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>基于锁的并发控制实现将写锁（在选定数据上获取）保持到事务结束，但是一旦执行SELECT操作，就会释放读锁（因此出现不可重复的读现象）。与重复读取一样，不管理范围锁。</p><h3 id="阅读未提交"><a href="#阅读未提交" class="headerlink" title="阅读未提交"></a>阅读未提交</h3><p>这是最低的隔离级别。在此级别，允许进行脏读取，因此一个事务可能会看到其他事务尚未提交的更改。</p><h2 id="基于锁的并发控制是什么"><a href="#基于锁的并发控制是什么" class="headerlink" title="基于锁的并发控制是什么"></a>基于锁的并发控制是什么</h2><p>锁分为两类：</p><ol><li>悲观锁：先取锁再访问</li><li>乐观锁：多版本控制就是一种乐观锁实现</li></ol><p>多版本控制详见<a href="https://blog.csdn.net/u012512634/article/details/72453511">【MySQL】MVCC(多版本并发控制)</a></p><h2 id="MySQL里面的事务控制"><a href="#MySQL里面的事务控制" class="headerlink" title="MySQL里面的事务控制"></a>MySQL里面的事务控制</h2><p>关闭自动提交(session级别), 每次执行单个逻辑工作单元后，手动<code>commit</code>提交/<code>rollback</code>回滚</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> blogs <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>使用<code>begin</code>(或者<code>start transaction</code>)显示开启一个事务，然后使用<code>commit</code>提交，或者<code>rollback</code>回滚</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> blogs <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Database_transaction">Wikipedia - Database transaction</a></li><li><a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)">Wikipedia - Isolation (database systems)</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html">MySQL 8.0 Reference Manual / Transaction Isolation Levels</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-acid.html">MySQL 8.0 Reference Manual / InnoDB and the ACID Model</a></li></ul>]]></content>
    
    
    <summary type="html">数据库事务是数据库管理系统执行过程中的一个逻辑单位，包含了一个有限的数据库操作序列。事务不是天然存在的东西，它是被人为创造出来，目的是简化应用层的编程模型。数据库事务有两个目的：（1）定义一个逻辑单位，以便于当数据库从故障中恢复的时候能正确地恢复数据；（2）提供一种隔离方式，以便于解决多个客户端并发操作的时候出现的奇怪问题。</summary>
    
    
    
    
    <category term="Database" scheme="http://zh-liang-cn.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>用Python的pulp库求解线性规划问题</title>
    <link href="http://zh-liang-cn.github.io/2020/01/19/use-python-pulp-solve-linear-planning-problem/"/>
    <id>http://zh-liang-cn.github.io/2020/01/19/use-python-pulp-solve-linear-planning-problem/</id>
    <published>2020-01-18T16:05:47.000Z</published>
    <updated>2021-10-30T16:18:49.741Z</updated>
    
    <content type="html"><![CDATA[<p>线性规划（Linear planning 或者 Linear programming）是最常见的优化技术，在运筹学（operation research）、规划（planning）等领域有很多的应用场景。虽然不像机器学习那样被大肆宣传，但是对可以通过具有线性关系的决策变量来表达的问题而言却是最首选的方法。</p><p><a href="https://book.douban.com/subject/26731100/">《数据、模型与决策：基于电子表格的建模和案例研究方法》</a>介绍了通过 Excel 来求解线性规划问题，本文介绍如何通过 Python 的 pulp 库来进行求解。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>案例来源于<a href="https://book.douban.com/subject/26731100/">《数据、模型与决策：基于电子表格的建模和案例研究方法》</a>中第3章的超级食品公司的广告组合问题。</p><p>该公司雇佣了一家广告公司来帮助设计全国性促销活动，<strong>以得到更多消费者的认可</strong>，该公司将根据广告公司所提供的服务给予一定的酬金，酬金预算不超过100万美元，投放的广告预算不超过400万美元。有三种广告媒介可以选择：周六增刊广告、杂志广告、电视广告。由于电视广告资源有限，只有5个时段可以投放。</p><p>广告成本如下：（单位：千美元）</p><table><thead><tr><th>成本分类</th><th>每次电视广告</th><th>每次杂志广告</th><th>每次周日增刊广告</th></tr></thead><tbody><tr><td>广告预算</td><td>300</td><td>150</td><td>100</td></tr><tr><td>规划预算</td><td>90</td><td>30</td><td>40</td></tr></tbody></table><p>广告媒介受众数量：（单位：千）</p><table><thead><tr><th></th><th>每次电视广告</th><th>每次杂志广告</th><th>每次周六增刊广告</th></tr></thead><tbody><tr><td>广告受众期望值</td><td>1300</td><td>600</td><td>500</td></tr></tbody></table><p>解决一个线性规划，有如下三步：</p><ol><li>找出决策变量（decision variable）</li><li>确定约束条件（functional constraint）</li><li>目标函数（objective function）</li></ol><h3 id="安装和起步"><a href="#安装和起步" class="headerlink" title="安装和起步"></a>安装和起步</h3><p>通过 pip 安装 pulp：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pulp</span><br></pre></td></tr></table></figure><p>首先要创建一个<code>LpProblem</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pulp <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">problem = LpProblem(<span class="string">&quot;Ads Optimization&quot;</span>, LpMaximize)</span><br></pre></td></tr></table></figure><p>第二个参数<code>LpMaximize</code>表示这个问题属于最大化问题。相应地，<code>LpMinimize</code> 则表示这个问题属于最小化问题。</p><p><code>LpProblem</code> 就像一个容器，后面会将 __决策变量__、 <strong>约束条件</strong> 和 <strong>目标函数</strong> 都放到这个容器中。</p><h3 id="决策变量"><a href="#决策变量" class="headerlink" title="决策变量"></a>决策变量</h3><p>第二步是定义决策变量，pulp 中定义决策变量的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = LpVariable(<span class="string">&quot;variableName&quot;</span>)</span><br></pre></td></tr></table></figure><p>默认是不设置上限和下限的，如果需要指定这个变量的上限和下限：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var = LpVariable(name, lowBound=<span class="literal">None</span>, upBound=<span class="literal">None</span>, cat=<span class="string">&#x27;Continuous&#x27;</span>, e=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><code>cat</code>表示Category，有三种：Integer, Binary 和 Continuous，默认是 Continuous。</p><p>如果决策变量比较多，而且这些决策变量属于同一种类型，也有相同的上限和下限，那么可以使用<code>dicts()</code>方法来统一创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">varDict = dicts(name, indexs, lowBound=<span class="literal">None</span>, upBound=<span class="literal">None</span>, cat=<span class="string">&#x27;Continuous&#x27;</span>, indexStart=[])</span><br></pre></td></tr></table></figure><p>这个例子中，一共有三个 决策变量，其中电视广告投放量是有上限约束的，其他两个则没有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tv = LpVariable(<span class="string">&quot;TV&quot;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">5</span>)</span><br><span class="line">m = LpVariable(<span class="string">&quot;Magazine&quot;</span>, lowBound=<span class="number">0</span>)</span><br><span class="line">ss = LpVariable(<span class="string">&quot;SS&quot;</span>, lowBound=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><p>接着使用决策变量来设置约束条件，这个例子中一共有两个约束条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c1 = <span class="number">300</span> * tv + <span class="number">150</span> * m + <span class="number">100</span> * ss &lt;= <span class="number">4000</span></span><br><span class="line">c2 = <span class="number">90</span> * tv + <span class="number">30</span> * m + <span class="number">40</span> * ss &lt;= <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">problem += c1</span><br><span class="line">problem += c2</span><br></pre></td></tr></table></figure><p>注意 <code>c1</code> 和 <code>c2</code> 实际上是一个表达式，最后则通过 <code>+=</code> 将两个约束条件添加到 <code>LpProblem</code> 对象中。</p><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>这个例子中，目标函数是广告整体的受众数量，可以通过第二个表格计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="number">1300</span> * tv + <span class="number">600</span> * m + <span class="number">500</span> * ss</span><br><span class="line"></span><br><span class="line">problem += obj</span><br></pre></td></tr></table></figure><p>最后仍然是通过 <code>+=</code> 将目标函数添加到 <code>LpProblem</code> 对象中。</p><p>如果要看下整个线性规划问题的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(problem)</span><br></pre></td></tr></table></figure><p>输出如下，非常容易理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AdsOptimization:</span><br><span class="line">MAXIMIZE</span><br><span class="line">600*Magazine + 500*SS + 1300*TV + 0</span><br><span class="line">SUBJECT TO</span><br><span class="line">_C1: 150 Magazine + 100 SS + 300 TV &lt;= 4000</span><br><span class="line"></span><br><span class="line">_C2: 30 Magazine + 40 SS + 90 TV &lt;= 1000</span><br><span class="line"></span><br><span class="line">VARIABLES</span><br><span class="line">Magazine free Continuous</span><br><span class="line">SS free Continuous</span><br><span class="line">TV &lt;= 5 Continuous</span><br></pre></td></tr></table></figure><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>准备好之后，通过调用 <code>solve()</code> 方法进行求解，返回 1 表示问题解决了，返回 -1 表示无法求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">problem.solve()</span><br></pre></td></tr></table></figure><p>通过<code>LpVariable.varValue</code>属性来获取找到的最优解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(tv.name + <span class="string">&quot; : &quot;</span> + <span class="built_in">str</span>(tv.varValue))</span><br><span class="line"><span class="built_in">print</span>(m.name + <span class="string">&quot; : &quot;</span> + <span class="built_in">str</span>(m.varValue))</span><br><span class="line"><span class="built_in">print</span>(ss.name + <span class="string">&quot; : &quot;</span> + <span class="built_in">str</span>(ss.varValue))</span><br></pre></td></tr></table></figure><p>输出的最优解为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TV : 0.0</span><br><span class="line">Magazine : 20.0</span><br><span class="line">SS : 10.0</span><br></pre></td></tr></table></figure><p>即不采用任何电视广告、投放20次杂志广告、投放10次周六增刊广告。</p><p><code>pulp.value()</code> 函数用于获取最终的目标函数值，这个例子中总的收益为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total_user = <span class="built_in">int</span>(value(problem.objective))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total users: &quot;</span> + <span class="built_in">str</span>(total_user))</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Total users: 17000</span><br></pre></td></tr></table></figure><p>也就是说这个广告投放组合可以带来17000千人次的广告受众量。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://pythonhosted.org/PuLP/pulp.html">Pulp函数库参考</a></li><li><a href="https://hackernoon.com/linear-programming-in-python-a-straight-forward-tutorial-a0d152618121">Linear Programming in Python</a></li><li><a href="https://towardsdatascience.com/linear-programming-and-discrete-optimization-with-python-using-pulp-449f3c5f6e99">Linear programming and discrete optimization with Python using PuLP</a></li></ul>]]></content>
    
    
    <summary type="html">线性规划（Linear planning 或者 Linear programming）是最常见的优化技术，在运筹学（operation research）、规划（planning）等领域有很多的应用场景。虽然不像机器学习那样被大肆宣传，但是对可以通过具有线性关系的决策变量来表达的问题而言却是最首选的方法。</summary>
    
    
    
    <category term="算法" scheme="http://zh-liang-cn.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="线性规划" scheme="http://zh-liang-cn.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
    <category term="Python" scheme="http://zh-liang-cn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>《Clean Code》阅读笔记</title>
    <link href="http://zh-liang-cn.github.io/2018/08/17/clean-code/"/>
    <id>http://zh-liang-cn.github.io/2018/08/17/clean-code/</id>
    <published>2018-08-17T14:06:41.000Z</published>
    <updated>2021-10-30T16:18:49.721Z</updated>
    
    <content type="html"><![CDATA[<p>《Clean Code-A Handbook of Agile Software Craftsmanship》中文名称是《代码整洁之道》，这本书出版于2008年，10年时间对于飞速发展的技术而言显得很长，因此，其中的部分道理已经显得有点过时。但是，瑕不掩瑜，这本书仍然是每个软件开发工程师都应该阅读、理解并且实践的行为标准。</p><p>从英文名看，这本书是一个Handbook，就意味着内容并不长，充其量一个中篇小说的长度，从这本书实质的内容（除掉附录和大篇幅的代码等外）来看，并不多，因此不用担心会用很长时间。</p><p>本书一共十七章，第一章是讲为什么要注重代码整洁，最后三章是JUnit例子、SerialDate例子、前面所有规则的归纳总结，有凑字数的嫌疑。核心是中间13章，从命名、函数、注释、格式、对象讲起，一直到类、系统、并发（性能）等。</p><p>本文按照整本书的章节结构做重点解读。解读之前，一定要明白：</p><blockquote><p>Team rules!（团队规则说了算），即便是你个人不同意，但一旦成为团队规则，你也得遵守。</p></blockquote><h2 id="第一章-整洁代码"><a href="#第一章-整洁代码" class="headerlink" title="第一章 整洁代码"></a>第一章 整洁代码</h2><h3 id="1-代码质量是生命线"><a href="#1-代码质量是生命线" class="headerlink" title="1. 代码质量是生命线"></a>1. 代码质量是生命线</h3><p>代码代表了一家公司的生产力水平、糟糕的代码可以毁掉一家公司。保持代码整洁，不仅仅关系到效率，也关系到生存。</p><h3 id="2-架构设计同样决定了代码整洁程度"><a href="#2-架构设计同样决定了代码整洁程度" class="headerlink" title="2. 架构设计同样决定了代码整洁程度"></a>2. 架构设计同样决定了代码整洁程度</h3><p>代码不仅仅是狭义的由字符组成的代码而已，也代表宏观的架构设计，因为架构设计也直接决定了代码的整洁程度</p><p>这个逻辑是：架构设计合理-&gt;边界划分清楚-&gt;代码行数少-&gt;代码整洁。</p><h3 id="3-不要挖坑"><a href="#3-不要挖坑" class="headerlink" title="3. 不要挖坑"></a>3. 不要挖坑</h3><p>存在问题就要改，而不是放到后面，或者优先级很低。其原因是：<strong>勒布朗法则</strong> 和 <strong>破窗理论</strong>，我们应该做到<strong>童子军规则</strong>。</p><p><strong>勒布朗/LaBlanc法则</strong></p><p>稍后等于永不（Later equals never）。</p><p><strong>破窗理论（Broken windows theory）</strong></p><p>一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火。一面墙，如果出现一些涂鸦没有被清洗掉，很快的，墙上就布满了乱七八糟、不堪入目的东西；一条人行道有些许纸屑，不久后就会有更多垃圾，最终人们会视若理所当然地将垃圾顺手丢弃在地上。这个现象，就是犯罪心理学中的破窗效应。</p><p>我们不仅不能做第N次打破窗户的人，我们还要努力做修复“第一扇窗户”的人。即使是当我们无法选择环境，甚至无力去改变环境时，我们还可以努力，那就是使自己不要成为一扇“破窗”。</p><p><strong>童子军军规</strong><br>让营地比你来时更干净。</p><h3 id="4-免责声明"><a href="#4-免责声明" class="headerlink" title="4. 免责声明"></a>4. 免责声明</h3><p>艺术书并不保证你读过之后能成为艺术家，只能告诉你其他艺术家用过的工具、技术和思维过程。本书也同样不担保你成为好程序员。</p><h2 id="第二章-命名"><a href="#第二章-命名" class="headerlink" title="第二章 命名"></a>第二章 命名</h2><p>命名是一个很小的细节，但是专业程度在此而体现。</p><p>代码应该是自解释的，要做到如下：</p><h3 id="1-名副其实"><a href="#1-名副其实" class="headerlink" title="1. 名副其实"></a>1. 名副其实</h3><ol><li> <strong>名副其实</strong>。比如 <code>int d</code> 不知道是什么用途，但是 <code>int daysSinceCreation</code> 就很清楚</li><li> 如果做不到名副其实，那至少<strong>不要有误导嫌疑</strong>吧。比如两个变量名特别像，只有一个字符差异</li><li> 还做不到那至少名字起得<strong>有意义</strong>吧。比如<code>a1</code>，<code>a2</code>这种真的就不要用了</li><li> 最好是能<strong>读得</strong>出来，比如<code>genymdms</code>，看起来是理解的，就是不好读出来，改成<code>generateDateTime</code>呢</li><li> <strong>使用常量</strong>，常量的一个好处在于方便搜索和定位，想想找<code>5</code>和<code>FIRDAY</code>的难度好了</li></ol><h3 id="2-顺其自然"><a href="#2-顺其自然" class="headerlink" title="2. 顺其自然"></a>2. 顺其自然</h3><ol><li> 不要使用<code>intXXX</code>、<code>strXXX</code>、<code>btnXXX</code>这样的了，看起来整洁，但是没什么用处，叫<code>saveButton</code>不是更好吗</li><li> Eclipse的编码习惯里面的<code>interface</code>都写成<code>IXXX</code>，看起来怪怪的，<code>Impl</code>加了就好了，接口并不用加。</li><li> 程序不是数学公式，数学公式为了追求抽象和简洁导致了不容易理解，对于程序而言，如果形象化容易理解就应该形象化，比如<code>port</code>总是比<code>p</code>要好</li><li>如果你不知道专业术语怎么说，<strong>别自己造词</strong>，多查一下</li><li>别扮可爱、不要在代码中表白</li></ol><h3 id="3-准确无歧义"><a href="#3-准确无歧义" class="headerlink" title="3. 准确无歧义"></a>3. 准确无歧义</h3><ol><li> 类名：避免<code>Manager</code>、<code>Processor</code>、<code>Info</code>这样的，这种类太多了，容易搞混；避免出现动词</li><li> 方法名：动词或者动词短语，如果是构造器，参数太多可以考虑<strong>Builder模式</strong>或者<strong>static初始化函数</strong>（可以自定义函数名，更容易理解，比如<code>Complex.fromRealNumber()</code>）</li><li> 每个概念对应一个词，定义好<code>find</code>、<code>get</code>、<code>fetch</code>、<code>retrive</code>的区别，并坚持</li><li> 避免双关语，比如<code>add()</code>，对于list而言最好是<code>insert</code>、<code>append</code>、<code>concat</code>，而不是简单的<code>add</code></li><li> 使用专业术语，比如你用了监听器模式，就应该起名为<code>Listener</code>、<code>Event</code></li></ol><h3 id="4-合理使用语境"><a href="#4-合理使用语境" class="headerlink" title="4. 合理使用语境"></a>4. 合理使用语境</h3><p>语境是指包名、类名、前缀，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SellerApplyStatusEnum</span> </span>&#123;</span><br><span class="line">    APPLY_STATUS_DEFAULT(<span class="number">0</span>, <span class="string">&quot;待审核&quot;</span>),</span><br><span class="line">    APPLY_STATUS_ENABLE(<span class="number">1</span>, <span class="string">&quot;通过审核&quot;</span>),</span><br><span class="line">    APPLY_STATUS_IGNORE(<span class="number">2</span>, <span class="string">&quot;忽略的申请&quot;</span>),</span><br><span class="line">    APPLY_STATUS_MODIFY(<span class="number">3</span>, <span class="string">&quot;退回修改&quot;</span>),</span><br><span class="line">    APPLY_STATUS_BRAND(<span class="number">4</span>, <span class="string">&quot;等待商家添加品牌&quot;</span>),</span><br><span class="line">    APPLY_STATUS_REJECT(<span class="number">5</span>, <span class="string">&quot;暂不合作&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个bad case，类名 <code>SellerApplyStatusEnum</code> 已经决定了语境了，所以 <code>APPLY_STATUS_MODIFY</code> 前面的 <code>APPLY_STATUS</code>是多余的，直接写成 <code>MODIFY(3, &quot;退回修改&quot;)</code> 更简洁。</p><ol><li> 名称一定是在语境中出现的，好的语境可以让变量在很短的情况下也容易理解，比如在Member的语境中，name就很容易理解成姓名</li><li> 不添加没有用的语境。</li></ol><h2 id="第三章-函数"><a href="#第三章-函数" class="headerlink" title="第三章 函数"></a>第三章 函数</h2><blockquote><p>函数的第一规则是短小，第二规则是更短小。究竟要多短，作者并没有说，大概10行上下吧。缩进层不应该超过2层。</p></blockquote><h3 id="1-函数应该只做一件事情"><a href="#1-函数应该只做一件事情" class="headerlink" title="1. 函数应该只做一件事情"></a>1. 函数应该只做一件事情</h3><p>一件事情可以拆分为 A、B、C 三个步骤（A、B、C 是同一个抽象层级），其中A又可以分为 A1、A2 两个步骤，B 可以分为 B1、B2、B3 两个步骤。</p><ol><li> 如果<code>f()</code>中做了 A、B、C 三件事情就可以认为是同一件事情。</li><li> 如果<code>f&#39;()</code>中做了 A1、A2、B、C 四件事情，就是做了不同事情了，因为他们是不同的抽象层级。</li></ol><p>保持函数中的<strong>任务始终是在同一个抽象层级上</strong>对于实现短的函数异常重要。</p><p>从这个意义上讲，编写函数是为了把高一层级的概念拆分成一系列低一层抽象层上的过程。</p><p>哪些函数可能不是只干了一件事情：</p><ol><li> 可以继续拆分的函数</li><li> 被用空行分成了多个区段的函数</li></ol><h3 id="2-参数与返回值"><a href="#2-参数与返回值" class="headerlink" title="2. 参数与返回值"></a>2. 参数与返回值</h3><p>最理想的是 0 参数，其次是 1 个，在次是 2 个，尽量避免 3 个，仅仅有非常特殊的原因才需要用 3 个以上。</p><p>那种 <code>true</code> 和 <code>false</code> 的参数最好不要用，而是拆成两个函数，更容易懂。</p><p>尽量用返回值，不要用参数来返回值。</p><h3 id="3-无副作用（side-effect）"><a href="#3-无副作用（side-effect）" class="headerlink" title="3. 无副作用（side-effect）"></a>3. 无副作用（side-effect）</h3><p>副作用会带来<strong>时序性耦合</strong>。比如在验证用户名和密码的函数中直接初始化了 HTTP Session，这就意味这个这个函数必须其他使用了 HTTP Session的函数之前调用。</p><p>应该尽量避免使用输出参数，如果函数必须要修改某种状态，就修改所属对象的属性。比如<code>appendFooter(Report report)</code>，改成<code>report.appendFooter()</code>。</p><h3 id="4-不求一开始就完美，保持迭代"><a href="#4-不求一开始就完美，保持迭代" class="headerlink" title="4. 不求一开始就完美，保持迭代"></a>4. 不求一开始就完美，保持迭代</h3><p>写出好的函数是一个迭代过程，“我并不一开始就按照规则写函数，我想没有人能做得到”。</p><h2 id="第四章-注释"><a href="#第四章-注释" class="headerlink" title="第四章 注释"></a>第四章 注释</h2><h3 id="1-一些思想（或者称为口舌之快）："><a href="#1-一些思想（或者称为口舌之快）：" class="headerlink" title="1. 一些思想（或者称为口舌之快）："></a>1. 一些思想（或者称为<em>口舌之快</em>）：</h3><ol><li> 注释是一种恶，因此越少越好。注释只有在代码无法表达其意思的时候才用。</li><li> 代码写得烂，注释再好也没用</li><li> 真正好的注释是你想办法不去写的注释</li><li> 需要写注释，是因为你的代码写得差</li></ol><p>有时候你觉得需要注释的时候可能尝试简化一下代码会更好，比如这种长代码长长的代码：<code>if (submodule.getDependSubsystems().contains(subSysMod.getSubsystems())) </code></p><h3 id="2-按功用分注释有三种"><a href="#2-按功用分注释有三种" class="headerlink" title="2. 按功用分注释有三种"></a>2. 按功用分注释有三种</h3><ol><li> 错误的：真正起作用的只有代码，容易改了代码忘记了改注释</li><li> 没用的：对代码重复（比如Java类的field的名称能代表其含义了，不用非得加上注释）</li><li> 有用的：对算法的解释、对代码目的解释</li></ol><h3 id="3-按用途分注释有两种"><a href="#3-按用途分注释有两种" class="headerlink" title="3. 按用途分注释有两种"></a>3. 按用途分注释有两种</h3><ol><li> 公共API中的JavaDoc这种（详细是必要的，但是也要遵守必要就好的原则，说明版本沿革等信息）</li><li> 内部系统中（越简单越好）</li></ol><h3 id="4-有用的注释"><a href="#4-有用的注释" class="headerlink" title="4. 有用的注释"></a>4. 有用的注释</h3><ol><li> 法律信息：有时候是必须的，如果能用链接替代最好，IDE能自动折叠起来</li><li> 提供信息：比如正则表达式不容易懂，加上一个例子</li><li> 对意图的解释：有时需求比较奇怪，加上简单说明可以解释为什么代码会是这样</li><li> 阐释：参数或者返回值有时不能很好的自表达，加上示例或者简单说明</li><li> 警示：记录一下在这里踩过的坑，让别人踩了</li><li> TODO：最好不要有，不是在系统中留下糟糕代码的接口</li><li> 放大：和警示一样，代码就一行，多加几行注释可以让后面的程序员更容易注意到</li></ol><h3 id="5-没啥用的注释"><a href="#5-没啥用的注释" class="headerlink" title="5. 没啥用的注释"></a>5. 没啥用的注释</h3><ol><li> 一些发泄情绪的语句：比如表白、招聘</li><li> 循规蹈矩类：比如内部系统中，所有的Java类的field都加上注释，只是为了通过checkstyle（可以改一下checkstyle规范）</li><li> 内部系统中的版本严格：完全可以在git或者svn中看到</li><li> 位置标记：比如 <code>/* constructor */</code>或者<code>/* private*/</code> 等这种在类中间做为分割的</li><li> 由于嵌套结构太长，放在结束位置的 <code>//end if</code>或者 <code>// end for</code> 这种</li><li> 署名：比如added by，版本控制里面可以查到的</li><li> 一些被注释掉的代码：记住这些代码一旦你删除了，以后一定没用</li></ol><h3 id="6-错误的注释"><a href="#6-错误的注释" class="headerlink" title="6. 错误的注释"></a>6. 错误的注释</h3><ol><li>误导性的：并没有揭露关键细节的，比如一个会遭遇并发情况的函数是否线程安全等</li><li>在注释之中硬编码，比如<code>“default is false&quot;</code>，要是以后代码中改成了<code>ture</code>，这个注释就错误了，最好是变成常量，在注释中引用一下</li></ol><h2 id="第五章-格式"><a href="#第五章-格式" class="headerlink" title="第五章 格式"></a>第五章 格式</h2><p>专业开发者的头等大事不是“让代码能够工作”，而是“沟通”。今天开发的功能可能下个版本中就被修改，代码可能被修改，但是<strong>代码风格和可读性长存</strong>。</p><p>对于Tomcat、JUnit的代码行数统计表明：</p><ol><li> 平均200行、最长500行的单个文件足以构造出色的系统</li><li> 平均80宽，最长120宽，应该保持代码行窄一点</li></ol><p>应该像报纸学习：最上部给出高层次概念和算法，细节往下渐次展开。多数短小精悍。</p><p>垂直方向上区隔：</p><ol><li> 方法之间区隔</li><li> 方法与字段之间区隔</li><li> 方法内逻辑处理之间区隔（比如for块前后）</li></ol><p>垂直方向上靠近：</p><ol><li> 类中相关字段放在一起</li><li> 有调用关系的方法放在一起</li><li> 同类的方法放到一起（比如重载方法）</li><li> 方法中变量的声明靠近其使用的地方</li></ol><p>水平方向上区隔&amp;靠近</p><ol><li> 运算符优先级（如 <code>*</code> 可以左右不空格，赋值一般要空格，这一点一般的格式检查工具并不会强制要求所以靠自觉）</li></ol><p>变量声明或者赋值对齐：</p><ol><li>意义不大（别浪费时间啦）</li></ol><h2 id="第六章-对象和数据结构"><a href="#第六章-对象和数据结构" class="headerlink" title="第六章 对象和数据结构"></a>第六章 对象和数据结构</h2><h3 id="1-对象和数据结构"><a href="#1-对象和数据结构" class="headerlink" title="1. 对象和数据结构"></a>1. 对象和数据结构</h3><p>在Java中容易误解一切都是对象（没有数据结构），实际上只要涉及编程一定就同时存在这两种东西，只是有时候会混用。</p><p>比如：</p><ol><li> Java中的DTO、常说的POJO也是一种数据结构，加上了 <code>getter</code> 和 <code>setter</code> 只是看起来更舒服一些</li><li> Ruby中的ActiveRecord实际上是一类特殊的DTO，包含了一些通用的行为</li></ol><p>我们常常会向DTO或者ActiveRecord中添加一些业务规则方法，这是错误的，更好的方法是创建一个新的类（DAO或者其他）来包含这些业务规则</p><p>“对象”与“数据结构”的区别：</p><ol><li> <strong>对象</strong>：暴露行为隐藏数据，便于增加对象类型而无需修改行为，难以在既有对象中增加行为</li><li> <strong>数据结构</strong>：暴露数据没有明显的行为，便于像既有数据结构增加行为，难以向既有函数增加新数据结构</li></ol><p>再解释一下：</p><ol><li>过程式的代码（使用数据结构的代码）<ol><li>便于在不改动既有数据结构的前提下，添加新函数</li><li>难于增加新的数据结构，因为必须修改所有的函数</li></ol></li><li>面向对象的代码（使用对象的代码）<ol><li>便于在不改动既有函数的情况下，增加新的类</li><li>难于增加新的函数，因为必须修改所有的类</li></ol></li></ol><h3 id="2-Demeter定律-得墨忒定律"><a href="#2-Demeter定律-得墨忒定律" class="headerlink" title="2. Demeter定律/得墨忒定律"></a>2. Demeter定律/得墨忒定律</h3><p>模块不应该了解他所操作的对象的内部情况。</p><p>类 C 的方法 f() 只应该调用以下对象的方法：</p><ol><li> C 的实例对象</li><li> 在 f() 中创建的对象</li><li> 作为参数传递给 f() 的对象</li><li> 由 C 的实例变量所持有的对象</li></ol><p>这里举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String outpuDir = ctx.getOptions().getScratchDir().getAbsolutePath();</span><br></pre></td></tr></table></figure><p>应该改成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options opts = ctx.getOptions();</span><br><span class="line">File scrathDir = opts.getScratchDir();</span><br><span class="line">outputDir = scratchDir.getAbsolutePath();</span><br></pre></td></tr></table></figure><p>当然这里是否应该这么改也取决于<code>Options</code>、<code>File</code>是数据结构还是对象，如果是数据结构，是没有行为的，就不适用于Demeter定律了。</p><blockquote><p>这里需要好好理解一下，为什么拆成三行后就符合Demeter定律了？</p></blockquote><p>一切都是对象只是一个传说。<strong>Getter</strong>和<strong>Setter</strong>将事情搞复杂了。</p><h2 id="第七章-错误处理"><a href="#第七章-错误处理" class="headerlink" title="第七章 错误处理"></a>第七章 错误处理</h2><h3 id="1-使用异常而非返回码（前提是语言支持异常）"><a href="#1-使用异常而非返回码（前提是语言支持异常）" class="headerlink" title="1. 使用异常而非返回码（前提是语言支持异常）"></a>1. 使用异常而非返回码（前提是语言支持异常）</h3><p>错误处理看起来和clean code没啥关系，但是如果它搞乱了代码逻辑，就是错误的做法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$member</span> = <span class="keyword">$this</span>-&gt;memberService-&gt;getById(<span class="variable">$id</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$member</span>) &#123;</span><br><span class="line">    <span class="variable">$name</span> = <span class="variable">$member</span>-&gt;name;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：如果是返回码，在调用完成之后就要马上检查返回码，会让代码变坏，而使用异常大可不必：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="variable">$member</span> = <span class="keyword">$this</span>-&gt;memberService-&gt;getById(<span class="variable">$id</span>);</span><br><span class="line">    <span class="variable">$name</span> = <span class="variable">$member</span>-&gt;name;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-推荐使用unchecked-exception-存疑）"><a href="#2-推荐使用unchecked-exception-存疑）" class="headerlink" title="2. 推荐使用unchecked exception(存疑）"></a>2. 推荐使用unchecked exception(存疑）</h3><p>Java中异常分为checked exception和runtime exception，前者需要在方法声明中显示声明，后者不需要</p><ol><li> 使用checked exception使得代码违反了“开闭原则”</li><li> 底层抛出的异常需要修改上层代码来支持</li><li> 对于关键liberary，checked exception很好，但是对于一般的应用开发好像有点多余</li></ol><h3 id="3-依调用者需要定义异常类"><a href="#3-依调用者需要定义异常类" class="headerlink" title="3. 依调用者需要定义异常类"></a>3. 依调用者需要定义异常类</h3><p>如果有一块方法调用抛出了很多异常，每次都逐个去catch有点浪费代码，最好是做个warpper，将多个异常catch住之后throw同一个出来。</p><p>考虑Special Case Pattern，创建一个类用来处理特例，特例在这个类里面处理了客户代码就不用应付异常行为了。</p><p>不要返回null值&amp;别传递null值，实在没办法使用<code>assert</code>语句比<code>throw InvalidArgumentException</code>要好一点</p><blockquote><p>要养成try-catch-finally的思考习惯</p></blockquote><h2 id="第八章-边界"><a href="#第八章-边界" class="headerlink" title="第八章 边界"></a>第八章 边界</h2><p>避免从公共API中使用Map、List这样通用数据结构的作为边界接口（参数、返回值）：</p><ol><li> 这些类功能太强了，容易出问题</li><li> 变动是可能的，比如Java 5.0加入泛型的时候带来了变动</li></ol><p>推荐学习型测试（将学习使用第三方库的代码通过单元测试的方式来组织）</p><ol><li> 免费的，学习型的代码你一定会写的</li><li> 不会浪费，以后升级库的时候可以再跑一遍看库是不是兼容</li></ol><p>对于第三方合作时，尽量将其交互接口放到单独的类中（Adapter）模式</p><ol><li> 便于组织和修改</li><li> 便于Mock或者Stub进行测试</li></ol><h2 id="第九章-单元测试"><a href="#第九章-单元测试" class="headerlink" title="第九章 单元测试"></a>第九章 单元测试</h2><p>TDD三定律：</p><ol><li> 在编写不能通过的单元测试前，不可编写代码</li><li> 只可编写刚好无法通过的单元测试，不能编译也算不通过</li><li> 只可编写刚好足以通过当前失败测试的生产代码</li></ol><p>从编写用后即扔的代码到编写全套自动化单元测试是一个非常大的进步</p><ol><li> 用后即扔的代码可以集合起来以后发生作用</li><li> 通过解除耦合和mock/stub方式来进行有效的单元测试</li><li> 测试代码和生产代码一样重要（测试越脏代码会越脏）</li></ol><p>整洁的测试又三个要素：可读性、可读性、可读性，按照如下模式：</p><ol><li> 构造（Build）</li><li> 操作（Operate）</li><li> 检验（Check）</li></ol><p>再抽象一个层次可以提供一些DSL类的测试语言（需要具有DSL能力的编程语言）</p><p>测试代码和生产代码的区别在于运行环境（的资源限制，如CPU和GPU），所以在测试环境中可以有一些不同的标准，但是代码整洁标准一定是相同的。</p><p>每个测试一个断言也许不一定好，一定好的是“尽可能减少每个概念的断言数量，而每个测试只测试一个概念”</p><h2 id="第十章-类"><a href="#第十章-类" class="headerlink" title="第十章 类"></a>第十章 类</h2><p>核心思想是<strong>越小越好</strong>，具体的实现手段是<strong>封装</strong>（好像是废话）</p><p>衡量标准：内聚性。<strong>一个类中的每个变量都被每个方法使用，则该类有最大的内聚性</strong></p><p>原则：</p><ol><li> 单一权责原则（SRP），类或者模块有且只有一个加以修改的理由</li><li> 开放闭合原则（OCP），类应该对扩展开放，对修改封闭</li></ol><p>方法：</p><ol><li>保持函数短小、保持函数的参数列表短 -&gt; 类的实例变量会增加 -&gt; 导致内聚性降低 -&gt; 将新的类从老的类中拆解出来</li><li>如果对一个系统需要修改而不是扩展才能增加新特性，那么这个类的内聚是不够的，可以拆分出多个类，来提升内聚性</li></ol><p>隔离首先的好处就是便于mock或者stub，便于测试。</p><h2 id="第十一章-系统"><a href="#第十一章-系统" class="headerlink" title="第十一章 系统"></a>第十一章 系统</h2><p>在有能力的市长不可能管理到每一个细节，总是有些人负责全局，有些人负责细节。在于演化出恰当的抽象等级和模块。</p><p>我们的软件系统感觉看起来很简单，所以在关注面切分和抽象层级方面做得非常不够。</p><h3 id="1-原则1：构造和使用分开"><a href="#1-原则1：构造和使用分开" class="headerlink" title="1. 原则1：构造和使用分开"></a>1. 原则1：构造和使用分开</h3><p>这段代码看起来实现了延迟初始化，非常棒，但是却让这个类依赖了MyServiceImpl，违反了抽象不能依赖于具体的原则。</p><p>后果是我们没办法创建MyServiceStub或者MyServiceMock来模拟Service的行为做单元测试了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Service getService()&#123;</span><br><span class="line">  if (service == null) &#123;</span><br><span class="line">    service = new MyServiceImpl(...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的方法有：</p><ol><li>抽奖工厂模式</li><li>依赖注入（Spring）</li></ol><h3 id="2-原则2：关注切面"><a href="#2-原则2：关注切面" class="headerlink" title="2. 原则2：关注切面"></a>2. 原则2：关注切面</h3><p>比如存储就是一个切面，Java中的GenericDao就是一个非常好的例子<a href="https://www.ibm.com/developerworks/library/j-genericdao/index.html">https://www.ibm.com/developerworks/library/j-genericdao/index.html</a></p><p>实现GenericDao的方式：</p><ol><li> java代理InvocationHandler</li><li> Spring AOP（没细说）</li><li> AspectJ（没细说）</li></ol><p>好处是将代码层面和架构关注面分离开，就有可能真正地用测试来驱动架构。</p><h3 id="原则3：创造并使用DSL降低复杂度"><a href="#原则3：创造并使用DSL降低复杂度" class="headerlink" title="原则3：创造并使用DSL降低复杂度"></a>原则3：创造并使用DSL降低复杂度</h3><p>DSL填平了领域概念和实现领域概念的代码之间的壕沟</p><p>整洁最终的目的都是提升敏捷能力。而提升敏捷能力的方法是TDD。能实现TDD依赖于系统的切分。</p><h2 id="第十二章-迭代"><a href="#第十二章-迭代" class="headerlink" title="第十二章 迭代"></a>第十二章 迭代</h2><p>Kent Beck关于简单设计的四条原则（以下规则优先级依次降低）：</p><h3 id="1-运行所有的测试"><a href="#1-运行所有的测试" class="headerlink" title="1. 运行所有的测试"></a>1. 运行所有的测试</h3><p>测试会让你遵守SRP、DIP，进而会使得系统贴近OO低耦合度高内聚的目标。</p><h3 id="2-不可重复"><a href="#2-不可重复" class="headerlink" title="2. 不可重复"></a>2. 不可重复</h3><p>抽取共性的代码可能会导致系统内聚降低，会违反SRP原则，因此这时需要做类的拆分</p><p>解决代码重复的比较好的类拆分方法是“模板方法模式”</p><h3 id="3-让代码易懂（具有表达力）"><a href="#3-让代码易懂（具有表达力）" class="headerlink" title="3. 让代码易懂（具有表达力）"></a>3. 让代码易懂（具有表达力）</h3><ol><li>选用好的名称，让人容易理解</li><li>保持函数和类尺寸短小</li><li>使用行业术语，比如Visitor、Factory、Builder等</li><li>编写良好的测试也能让人更容易理解，就像一个example一样</li></ol><p>最终：用心是最珍贵的资源，尊重你的手艺。</p><h3 id="4-尽可能减少类和方法的数量"><a href="#4-尽可能减少类和方法的数量" class="headerlink" title="4. 尽可能减少类和方法的数量"></a>4. 尽可能减少类和方法的数量</h3><p>有可能前面几个原则可能会过度使用，比如 <code>ServiceInterface</code> 和 <code>ServiceImpl</code> ，不要太教条。</p><h2 id="第十三章-并发编程"><a href="#第十三章-并发编程" class="headerlink" title="第十三章 并发编程"></a>第十三章 并发编程</h2><p>对象是过程的抽象，线程是调度的抽象。并发是一种解耦机制：将何事（目的）和何时（时机）分解开。好处是<strong>可以明显地改进吞吐量和结构</strong>（将循环变成独立的参与者，有利于切分关注面）。</p><p>常见错误：</p><ol><li> 并发总是能改进性能：得看情况，比如CPU密集型再并发计算就没有意义了</li><li> 编写并发程序无需修改设计</li><li> 对于一般的后端开发，无需考虑并发</li></ol><p>正确的理解：</p><ol><li> 并发会在性能上增加一些开销</li><li> 并发的程序会更加复杂</li><li> 并发容易出现偶发性错误，而这些错误容易被忽略</li><li> 并发需要测底对系统进行重新设计（简单重构并不会解决问题）</li></ol><p>并发防御原则：</p><ol><li> 单一权责原则</li><li> 推论：限制数据作用域（保护临界区）</li><li> 推论：使用数据副本（减少sideeffect）</li><li> 推论：线程尽可能地独立（减少或者不与其他线程共享数据）</li></ol><p>Java中的并发库：</p><ol><li> java.util.concurrent</li><li> java.util.concurrent.atomic</li><li> java.util.concurrent.locks</li></ol><p>Java中的并发类：</p><ol><li>ConcurrentHashMap几乎在所有的情况下实现都比HashMap好。</li><li>ReentrantLock：可以在一个方法中获取、在另一个方法中释放的锁。</li><li>Semaphore：经典的“信号”的一种实现，有计数器的锁</li><li>CountDownLatch：在释放所有等待的线程前，等待制定数量时间发生的锁。这样，所有的线程都平等的几乎同时启动</li></ol><h2 id="第十四章-逐步改进"><a href="#第十四章-逐步改进" class="headerlink" title="第十四章 逐步改进"></a>第十四章 逐步改进</h2><p>Java是一种唠叨型语言，要特别注意代码的简短，不简短一定没有可读性。</p><p>别随意重构，毁坏程序的最好办法之一就是以改进之名大动其结构。</p><ol><li> 为避免这种情况应该采用TDD</li><li> TDD核心原则之一就是保持系统始终能运行</li></ol><p>优秀的软件设计，大都关乎分割——创建合适的空间放置不同种类的代码。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>艺术书并不保证你读过之后能成为艺术家，只能告诉你其他艺术家用过的工具、技术和思维过程。读完本文也同样不担保你成为好程序员。但是，分享本文，应该可以供你装逼！</p><p><img src="https://zh-liang-cn.oss-cn-hangzhou.aliyuncs.com/images/20200103230403.png"></p><p>你还得练，孩子，还得练！共勉。</p><p><img src="https://zh-liang-cn.oss-cn-hangzhou.aliyuncs.com/images/20200103230526.png"></p><p>上图为最后笑话中的<strong>卡耐基音乐厅</strong>，位于纽约市第七大道881号，第56大街和第57大街中间，占据第七大道东侧。由慈善家安德鲁·卡耐基(Andrew Carnegie)出资建于1890年，是美国古典音乐与流行音乐界的标志性建筑。卡耐基音乐厅以历史悠久，外形美观以及声音效果出色而着称。</p>]]></content>
    
    
    <summary type="html">《Clean Code-A Handbook of Agile Software Craftsmanship》中文名称是《代码整洁之道》，这本书出版于2008年，10年时间对于飞速发展的技术而言显得很长，因此，其中的部分道理已经显得有点过时。但是，瑕不掩瑜，这本书仍然是每个软件开发工程师都应该阅读、理解并且实践的行为标准。</summary>
    
    
    
    
    <category term="读书笔记" scheme="http://zh-liang-cn.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是声明式编程语言</title>
    <link href="http://zh-liang-cn.github.io/2018/05/18/declarative-language/"/>
    <id>http://zh-liang-cn.github.io/2018/05/18/declarative-language/</id>
    <published>2018-05-18T14:08:12.000Z</published>
    <updated>2021-10-30T16:18:49.722Z</updated>
    
    <content type="html"><![CDATA[<p>最近了解了neo4j的Cypher语言以及drools的规则语言，这两种语言都是“声明式语言”，因此有必要弄清楚声明式语言究竟是什么。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>声明式语言（Declarative Language）是相对于命令式语言（Imperative Language）而言的，其实我们天天在用这两类语言。</p><p>命令式语言典型的例子是C、Java、PHP等语言，其特点是提供了if-else、foreach等基本逻辑控制命令（英语中成为primitives），使得我们可以通过这些基本单元来描述完成任务的过程。</p><p>声明式语言的典型例子是SQL或者XQuery（可能比较少用，但是XPath是XQuery的一部分，应该大部分人都知道的），声明式语言是一种更为高级（Higher level）的语言，使用的时候并不需要去描述具体实现任务的步骤，只需要描述希望达成的目的。比如，在用SQL的时候，你只需要告诉DB希望查询什么数据（如<code>select * from books</code>），而DB会执行相应的处理流程来完成任务。DSL也是非常典型的声明式语言。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>说到这里，可能你还是不明白这两者到底有什么不同。你会说诸如SQL这样的声明式语言也有<code>foreach</code>这种基本逻辑控制命令。是的，本质上而言，命令式语言是描述过程，而声明式语言是描述目标。但是站在不同的层次，过程可能也是目标，而目标也可能成为过程。</p><p>后来我想到，产品经理写文档就是天然的声明式编程，他们更多的是描述希望达到的目标；而作为程序员，我们写下的每一行代码就是命令式编程。</p><p>这是一行产品需求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需求名称：用户第一次购买了铅笔后发送一张削笔刀现金券</span><br><span class="line">场景：用户购买铅笔支付成功结果页</span><br><span class="line">判断条件：用户是第一次购买铅笔</span><br><span class="line">具体动作：给用户发送一张满5减1的削笔刀现金券</span><br></pre></td></tr></table></figure><p>这个需求用抽象语言（DSL）描述成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in_scenario: </span><br><span class="line">    pay_result_page</span><br><span class="line">test:</span><br><span class="line">    user_buy_pencil &amp;&amp; user_buy_pencil_for_the_first_time</span><br><span class="line">action:</span><br><span class="line">    send_a_5_plus_1_coupon</span><br></pre></td></tr></table></figure><p>但是当我们来实现的时候我们会做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user = UserService.getById(uid)</span><br><span class="line">orderItem = OrderService.getById(oiid);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.buyPencilForTheFirstTime(user) </span><br><span class="line">        &amp;&amp; orderItem.getCategory().equals(<span class="string">&quot;pencil&quot;</span>)) </span><br><span class="line">    <span class="keyword">this</span>.sendCoupon(uid, couponId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现在声明式语言中，你需要用到<code>user_buy_pencil</code>这样的语法，而在命令式语言中，我们使用了更基本的状态判断。所以，声明式编程用到的更多是Problem Domain（问题域）语法，而命令式编程更多的是用到Primitive（基本控制单元）语法。这个例子中的，<code>in_scenario</code>也可以认为是产品经理专用语言，用于描述需求。</p><h2 id="具体的例子"><a href="#具体的例子" class="headerlink" title="具体的例子"></a>具体的例子</h2><p>多年以前阅读<a href="http://learnyouahaskell.com/chapters">《Learn You a Haskell for Great Good!》</a>这本书读到一个例子，题目是：求边长小于10并且是整数的直角三角形。</p><p><img src="https://zh-liang-cn.oss-cn-hangzhou.aliyuncs.com/images/20200103232628.png"></p><p>拿到这个问题，一看挺简单啊，判定直接三角形就是用勾股定律嘛，”Life is short, you need Python”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, a+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, b+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> b**<span class="number">2</span> + c**<span class="number">2</span> == a**<span class="number">2</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;a=%d, b=%d, c=%d&quot;</span> % (a, b, c))</span><br></pre></td></tr></table></figure><p>然而，我们看看在Haskell语言中的实现：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = print [ (a,b,c) | c &lt;- [<span class="number">1.</span><span class="number">.10</span>], </span><br><span class="line">                         b &lt;- [<span class="number">1.</span>.c], </span><br><span class="line">                         a &lt;- [<span class="number">1.</span>.b], </span><br><span class="line">                         a^<span class="number">2</span> + b^<span class="number">2</span> == c^<span class="number">2</span>] </span><br></pre></td></tr></table></figure><p>鹅妹子嘤！是不是有点像数学中学习的集合表达式？对，就是描述一下问题，就可以自动求解，这就是一个非常典型的声明式编程的例子。</p><p><img src="https://zh-liang-cn.oss-cn-hangzhou.aliyuncs.com/images/20200103232733.png"></p><p>如果你不信，点击这里来执行一下：<a href="https://repl.it/@LiangZhou1/SatisfiedGlassParallelport">https://repl.it/@LiangZhou1/SatisfiedGlassParallelport</a></p>]]></content>
    
    
    <summary type="html">最近了解了neo4j的Cypher语言以及drools的规则语言，这两种语言都是“声明式语言”，因此有必要弄清楚声明式语言究竟是什么。
</summary>
    
    
    
    
    <category term="编程语言" scheme="http://zh-liang-cn.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Git笔记</title>
    <link href="http://zh-liang-cn.github.io/2014/06/04/git-tips/"/>
    <id>http://zh-liang-cn.github.io/2014/06/04/git-tips/</id>
    <published>2014-06-04T06:56:26.000Z</published>
    <updated>2021-10-30T16:18:49.724Z</updated>
    
    <content type="html"><![CDATA[<p>工作中越来越离不开 <a href="http://git-scm.com/">git</a>，深感 <a href="http://git-scm.com/">git</a> 的功能强大，基本上你会用到的、你能想到的功能都可以实现。本文是笔者遇到的问题以及解决方法的汇总，希望对读者有所帮助。</p><h2 id="git工具"><a href="#git工具" class="headerlink" title="git工具"></a>git工具</h2><ul><li>tig：控制台的GUI工具，通过<code>sudo apt-get install tig</code>或者<code>brew install tig</code>即可安装，强烈推荐</li><li>gitk：GUI工具，使用tcl/tk编写，Ubuntu上默认已经安装了，直接在控制台执行<code>gitk</code>即可以启动</li><li>SourceTree：著名的<a href="https://www.atlassian.com/">Atlassian</a>的_免费_产品，支持Mac和Windows，但是_不_支持Linux，下载地址：<a href="http://www.sourcetreeapp.com/">sourcetreeapp.com</a></li></ul><h2 id="只提交文件中的某几行改动而不是全部的改动"><a href="#只提交文件中的某几行改动而不是全部的改动" class="headerlink" title="只提交文件中的某几行改动而不是全部的改动"></a>只提交文件中的某几行改动而不是全部的改动</h2><p>执行<code>git add -p &lt;filename.java&gt;</code>命令，git会逐块（hunk）地询问你是否要提交这一块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stage this hunk [y,n,q,a,d,/,j,J,g,s,e,?]? ??</span><br><span class="line">y - stage this hunk</span><br><span class="line">n - do not stage this hunk</span><br><span class="line">q - quit; do not stage this hunk nor any of the remaining ones</span><br><span class="line">a - stage this hunk and all later hunks in the file</span><br><span class="line">d - do not stage this hunk nor any of the later hunks in the file</span><br><span class="line">g - select a hunk to go to</span><br><span class="line">/ - search for a hunk matching the given regex</span><br><span class="line">j - leave this hunk undecided, see next undecided hunk</span><br><span class="line">J - leave this hunk undecided, see next hunk</span><br><span class="line">k - leave this hunk undecided, see previous undecided hunk</span><br><span class="line">K - leave this hunk undecided, see previous hunk</span><br><span class="line">s - split the current hunk into smaller hunks</span><br><span class="line">e - manually edit the current hunk</span><br><span class="line">? - print help</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git">Commit only part of a file in Git</a></li></ul><h2 id="Checkout远程分支"><a href="#Checkout远程分支" class="headerlink" title="Checkout远程分支"></a>Checkout远程分支</h2><pre><code>$ git checkout --track origin/daves_branch</code></pre><p>这会创建一个名称 daves_branch 的本地分支</p><p>参考：</p><ul><li><a href="http://stackoverflow.com/questions/9537392/git-fetch-remote-branch">http://stackoverflow.com/questions/9537392/git-fetch-remote-branch</a></li></ul><h2 id="将已经commit到本地但是还没push到远程仓库的commit拆分成多个commit"><a href="#将已经commit到本地但是还没push到远程仓库的commit拆分成多个commit" class="headerlink" title="将已经commit到本地但是还没push到远程仓库的commit拆分成多个commit"></a>将已经commit到本地但是还没push到远程仓库的commit拆分成多个commit</h2><p>如果是上一个commit，即HEAD~1，可以<code>git reset HEAD~1 --soft</code>，本地仓库会回到上一个commit提交前的状态，然后根据你的需要分成多个commit即可。</p><p>如果是前几次commit，比如HEAD~3，可以按如下步骤：</p><ul><li>使用<code>git rebase -i HEAD~4</code>进入交互式rebase</li><li>将你需要拆分的那个commit改成edit状态</li><li>此时当前工作的commit是处于已经提交的状态，使用<code>git reset HEAD~1</code>将其恢复成提交前的状态</li><li>根据你的需要分别使用<code>git add</code>和<code>git commit</code>提交</li></ul><p>这里：</p><ul><li>可以使用<code>git add -p &lt;file name&gt;</code>来实现对一个文件中修改分多次提交</li><li>可以使用<code>git commit -c ORIG_HEAD</code>来重用拆分的那个commit的commit message</li></ul><p>参考：</p><ul><li><a href="http://stackoverflow.com/questions/1440050/how-to-split-last-commit-into-two-in-git">http://stackoverflow.com/questions/1440050/how-to-split-last-commit-into-two-in-git</a></li><li><a href="http://stackoverflow.com/questions/4307095/git-how-to-split-up-a-commit-buried-in-history">Git: How to split up a commit buried in history</a></li></ul><h2 id="撤销reset-rebase-cherry-pick-checkout-commit操作"><a href="#撤销reset-rebase-cherry-pick-checkout-commit操作" class="headerlink" title="撤销reset/rebase/cherry-pick/checkout/commit操作"></a>撤销reset/rebase/cherry-pick/checkout/commit操作</h2><p>使用<code>git reset HEAD~1</code>可以很方便的撤销上一次的commit，但是仍然将修改过的文件保存在缓存区，有时会想再将这个commit还原回来，这时该怎么办呢？</p><p>Git实际上将HEAD的变动都保存在了reflog中，使用<code>git reflog</code>可以查看，你也可以认为git保存了所有的_commit_、_reset_、_rebase_、_cherry-pick_、_checkout_操作的历史记录，因此代码一旦commit就不用担心丢失了（除非删掉了本地库）。</p><p>使用<code>git reflog</code>可以看到所有这些操作，然后使用<code>git reset</code></p><pre><code>$ git reflog -5c60995b HEAD@&#123;0&#125;: rebase -i (finish): returning to refs/heads/masterc60995b HEAD@&#123;1&#125;: rebase -i (pick): add d91c3a01 HEAD@&#123;2&#125;: commit: add c9ac23cf HEAD@&#123;3&#125;: commit: add b38b72b4 HEAD@&#123;4&#125;: reset: moving to HEAD~1</code></pre><p>如果需要回到<code>91c3a01 HEAD@&#123;2&#125;: commit: add c</code>这个commit，直接执行<code>git reset 91c3a01</code>或者更加直观<code>git reset HEAD@&#123;2&#125;</code>即可。</p><p>这里的<code>-5</code>意思是只显示5行，<code>git log -5</code>也只显示最近5个commit的log</p><p>参考</p><ul><li>[<a href="http://stackoverflow.com/questions/2510276/undoing-git-reset]">http://stackoverflow.com/questions/2510276/undoing-git-reset]</a>(Undoing git reset?)</li><li><a href="http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html">reflog, your safety net</a></li></ul><h2 id="git-co与git-st命令是怎么回事"><a href="#git-co与git-st命令是怎么回事" class="headerlink" title="git co与git st命令是怎么回事"></a><code>git co</code>与<code>git st</code>命令是怎么回事</h2><p>git允许定义命令的别名，根据约定俗成，这里<code>co</code>是<code>checkout</code>的别名、<code>st</code>是<code>status</code>的别名，也就是说可以使用<code>git co</code>来替代<code>git checkout</code>命令。</p><p>有两种方法可以添加这种别名，第一种是直接编辑_~/.gitconfig_文件，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">  co = checkout</span><br><span class="line">  ci = commit</span><br><span class="line">  st = status</span><br><span class="line">  br = branch</span><br><span class="line">  hist = log --pretty=format:\&quot;%h %ad | %s%d [%an]\&quot; --graph --date=short</span><br><span class="line">  type = cat-file -t</span><br><span class="line">  dump = cat-file -p</span><br></pre></td></tr></table></figure><p>第二种是通过<code>git config</code>命令来配置，依次执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.hist &#x27;log --pretty=format:&quot;%h %ad | %s%d [%an]&quot; --graph --date=short&#x27;</span><br><span class="line">git config --global alias.type &#x27;cat-file -t&#x27;</span><br><span class="line">git config --global alias.dump &#x27;cat-file -p&#x27;</span><br></pre></td></tr></table></figure><h2 id="取出某个特定文件的某个特定版本"><a href="#取出某个特定文件的某个特定版本" class="headerlink" title="取出某个特定文件的某个特定版本"></a>取出某个特定文件的某个特定版本</h2><p><code>git checkout</code>命令用来切换分支，会取出整个分支的代码，但是也可以用来取出某个特定的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit SHA&gt; &lt;filepath&gt;</span><br></pre></td></tr></table></figure><h2 id="设置commit-message模板"><a href="#设置commit-message模板" class="headerlink" title="设置commit message模板"></a>设置commit message模板</h2><p>将commit message写到一个文件中，然后执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global commit.template ~/.git.commit.template</span><br></pre></td></tr></table></figure><h2 id="将commit从一个repo移动到另一个repo"><a href="#将commit从一个repo移动到另一个repo" class="headerlink" title="将commit从一个repo移动到另一个repo"></a>将commit从一个repo移动到另一个repo</h2><p>使用_git format-patch_命令会为每一个commit生成一个patch文件，然后使用_git apply_命令将生成额patch文件应用到另一个仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git format-patch &lt;first commit SHA&gt;~..&lt;first commit SHA&gt;</span><br><span class="line">git apply &lt;path to patch&gt;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html">git-format-patch(1) Manual Page</a></li><li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-apply.html">git-apply(1) Manual Page</a></li><li><a href="http://makandracards.com/makandra/5531-git-move-a-commit-between-repositories">Git: Move a commit between repositories</a></li></ul><h2 id="忽略文件夹"><a href="#忽略文件夹" class="headerlink" title="忽略文件夹"></a>忽略文件夹</h2><p>只需要将文件夹名称加入_.gitignore_文件即可，注意，所有子文件夹下的这个目录都会被忽略，除非</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config/                 # 忽略config/文件夹</span><br><span class="line">!configuration/config/  # 不要忽略configuration文件夹下的config文件夹</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.kernel.org/pub/software/scm/git/docs/gitignore.html">gitignore(5) Manual Page</a></li></ul><h2 id="git-stash-命令"><a href="#git-stash-命令" class="headerlink" title="git stash 命令"></a>git stash 命令</h2><p><code>git stash</code>命令可以将改动暂存起来:</p><pre><code>$ git stash$ git stash pop $ git stash list$ git stash drop</code></pre><p>查看stash中的改动：</p><pre><code>$ git stash show$ git stash show -p$ git stash show -p stash @&#123;1&#125;</code></pre><p>参考：</p><ul><li><a href="http://stackoverflow.com/questions/10725729/git-see-whats-in-a-stash-without-applying-stash">Git: see what’s in a stash without applying stash</a></li></ul><h2 id="push本地的某个commit"><a href="#push本地的某个commit" class="headerlink" title="push本地的某个commit"></a>push本地的某个commit</h2><p>如果临时做了一个patch，只希望push这一个commit到repo中:</p><pre><code>$ git push &lt;remotename&gt; &lt;commit SHA&gt;:&lt;remotebranchname&gt;</code></pre><p>参考：</p><ul><li><a href="http://stackoverflow.com/questions/3230074/git-pushing-specific-commit">git - pushing specific commit</a></li></ul><h2 id="git远程分支操作"><a href="#git远程分支操作" class="headerlink" title="git远程分支操作"></a>git远程分支操作</h2><h3 id="push本地分支到repo"><a href="#push本地分支到repo" class="headerlink" title="push本地分支到repo"></a>push本地分支到repo</h3><p>在本地创建了一个分支后，需要将这个分支push到远程repo中：</p><pre><code>$ git push origin new_feature</code></pre><h3 id="删除远程repo中的分支"><a href="#删除远程repo中的分支" class="headerlink" title="删除远程repo中的分支"></a>删除远程repo中的分支</h3><pre><code>$ git push origin :new_feature # 注意里面的冒号</code></pre><p>参考：</p><ul><li><a href="http://gitready.com/beginner/2009/02/02/push-and-delete-branches.html">push and delete remote branches</a></li></ul><h3 id="将本地分支恢复到远程仓库的HEAD状态"><a href="#将本地分支恢复到远程仓库的HEAD状态" class="headerlink" title="将本地分支恢复到远程仓库的HEAD状态"></a>将本地分支恢复到远程仓库的HEAD状态</h3><pre><code>$ git fetch origin$ git reset --hard origin/mainline$ git clean -f -d</code></pre><p>其中：_-f_表示_force_，_-d_表示_clean directory_</p><p>参考：</p><ul><li><a href="http://ocpsoft.org/tutorials/git/reset-and-sync-local-respository-with-remote-branch/">Reset and sync local respository with remote branch</a></li></ul><h3 id="只merge另一个分支的某个commit"><a href="#只merge另一个分支的某个commit" class="headerlink" title="只merge另一个分支的某个commit"></a>只merge另一个分支的某个commit</h3><p>使用_git cherry-pick_命令：</p><pre><code>$ git cherry-pick &lt;commit SHA&gt;</code></pre><p>参考：</p><ul><li><a href="http://stackoverflow.com/questions/881092/how-to-merge-a-specific-commit-in-git">How to merge a specific commit in git</a></li></ul><h2 id="删除还未push的commit"><a href="#删除还未push的commit" class="headerlink" title="删除还未push的commit"></a>删除还未push的commit</h2><p>_HEAD~1_表示恢复到上一个版本，这里可以替换成commit的SHA值：</p><pre><code>$ git reset --hard HEAD~1</code></pre><h2 id="修改还未push的上一次commit"><a href="#修改还未push的上一次commit" class="headerlink" title="修改还未push的上一次commit"></a>修改还未push的上一次commit</h2><p>如果需要对刚刚提交到本地repo的commit进行修改：</p><pre><code>$ git reset --soft HEAD^$ do some change$ git add -A$ git commit -c ORIG_HEAD</code></pre><p>参考：</p><ul><li><a href="http://stackoverflow.com/questions/927358/how-to-undo-the-last-git-commit">How to undo the last Git commit?</a></li></ul><h2 id="生成SSH-public-keys"><a href="#生成SSH-public-keys" class="headerlink" title="生成SSH public keys"></a>生成SSH public keys</h2><pre><code>$ ssh-keygen -t rsa</code></pre><p>参考：</p><ul><li><a href="https://help.github.com/articles/set-up-git">Set Up Git</a></li></ul><h2 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h2><h3 id="显示本地分支信息"><a href="#显示本地分支信息" class="headerlink" title="显示本地分支信息"></a>显示本地分支信息</h3><pre><code>$ git branch* master</code></pre><h3 id="创建新的branch"><a href="#创建新的branch" class="headerlink" title="创建新的branch"></a>创建新的branch</h3><pre><code>$ git branch testing$ git branch* master  testing</code></pre><h3 id="切换到新创建的branch"><a href="#切换到新创建的branch" class="headerlink" title="切换到新创建的branch"></a>切换到新创建的branch</h3><pre><code>$ git checkout testing$ git branch  master* testing</code></pre><h3 id="创建branch的同时切换到新创建的branch"><a href="#创建branch的同时切换到新创建的branch" class="headerlink" title="创建branch的同时切换到新创建的branch"></a>创建branch的同时切换到新创建的branch</h3><pre><code>$ git checkout -b testing2$ git branch  master  testing* testing2</code></pre><h3 id="删除branch"><a href="#删除branch" class="headerlink" title="删除branch"></a>删除branch</h3><pre><code>$ git branch -d testing$ git branch  master* testing2</code></pre><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><pre><code>$ git branch master$ git branch* master  testing2$ git merge testing2</code></pre><p>参考：</p><ul><li><a href="http://gitref.org/branching/">http://gitref.org/branching/</a></li><li><a href="http://darrinholst.com/post/359817782">http://darrinholst.com/post/359817782</a></li></ul><h2 id="修改最近一次提交的message"><a href="#修改最近一次提交的message" class="headerlink" title="修改最近一次提交的message"></a>修改最近一次提交的message</h2><p>使用_git commit_的_–amend_参数：</p><p>  git commit –amend -m “some other message”</p><p>修改前几次提交的但是还没push到remote repository的commit的message</p><pre><code>$ git lg* 6119426 - (master) third commit (3 seconds ago by Darrin Holst)* b6a0a9f - we want to change this message (23 seconds ago by Darrin Holst)* e24b57d - first commit (37 seconds ago by Darrin Holst)</code></pre><h2 id="交互式rebase"><a href="#交互式rebase" class="headerlink" title="交互式rebase"></a>交互式rebase</h2><p>使用_git rebase_的_-i_参数：</p><pre><code>$ git rebase -i HEAD~2</code></pre><p>将在编辑器中打开：</p><pre><code>pick b6a0a9f we want to change this messagepick 6119426 third commit# Rebase e24b57d..6119426 onto e24b57d## Commands:#  p, pick = use commit#  e, edit = use commit, but stop for amending#  s, squash = use commit, but meld into previous commit</code></pre><p>将第一个commit改成edit：</p><pre><code>Change “pick” to “edit” for those that you want to edit and save that fileedit b6a0a9f we want to change this messagepick 6119426 third commit# Rebase e24b57d..6119426 onto e24b57d## Commands:#  p, pick = use commit#  e, edit = use commit, but stop for amending#  s, squash = use commit, but meld into previous commit</code></pre><p>进行相应的修改：</p><pre><code>Now amend that commit$ git commit --amend -m &quot;some other message&quot;</code></pre><p>接着继续rebase操作：</p><pre><code>$ git rebase --continue$ git lg* cec3fba - (master) third commit (2 seconds ago by Darrin Holst)* c146f90 - some other message (29 seconds ago by Darrin Holst)* e24b57d - first commit (5 minutes ago by Darrin Holst)</code></pre>]]></content>
    
    
    <summary type="html">工作中越来越离不开&lt;em&gt;&lt;a href=&quot;http://git-scm.com&quot;&gt;git&lt;/a&gt;&lt;/em&gt;，深感&lt;em&gt;&lt;a href=&quot;http://git-scm.com&quot;&gt;git&lt;/a&gt;&lt;/em&gt;的功能强大，基本上你会用到的、你能想到的功能都可以实现。本文是笔者遇到的问题以及解决方法的汇总，希望对读者有所帮助。</summary>
    
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux mount命令详解</title>
    <link href="http://zh-liang-cn.github.io/2014/05/23/linux-mount-command/"/>
    <id>http://zh-liang-cn.github.io/2014/05/23/linux-mount-command/</id>
    <published>2014-05-22T23:10:23.000Z</published>
    <updated>2021-10-30T16:18:49.730Z</updated>
    
    <content type="html"><![CDATA[<p>_mount_命令在我心目中一直是个高大上的命令：首先，经常看见长度很长的_mount_命令；其次，是直接配置硬件的命令，敲命令的时候总是难免担心把机器搞挂了。因此，我一直以来在Mac OS和Ubuntu中都依靠操作系统自动检查插入的磁盘，就像在Windows里面一样，简直弱爆了。今天就抽空把整理一下这方面的知识。</p><h2 id="mount命令结构"><a href="#mount命令结构" class="headerlink" title="mount命令结构"></a>mount命令结构</h2><p>先举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw -t yaffs2 /dev/block/mtdblock3 /system</span><br></pre></td></tr></table></figure><p>这个例子里面基本分为四部分，也是我们最常用的四部分：</p><ul><li><code>-o remount,rw</code>，指定选项</li><li><code>-t yaffs2</code>，指定挂载磁盘上的文件系统的类型，这里的_yaffs2_是_Android_的文件系统类型</li><li><code>/dev/block/mtdblock3</code>，指定磁盘的路径</li><li><code>/system</code>，指定挂载点</li></ul><p>也就是这样：</p><pre><code>mount -o &lt;选项&gt; -t &lt;文件系统类型&gt; &lt;磁盘路径&gt; &lt;挂载点&gt;</code></pre><p>需要注意的是：</p><ul><li><code>-t</code>一般情况下不用自定，操作系统会自动识别</li><li>磁盘路径查看方法：Linux: <code>fdisk -l</code>；Mac：<code>diskutil list</code></li></ul><blockquote><p>关于_fdisk_和_diskutil_，请参考：<a href="http://superuser.com/questions/671725/what-is-the-equivalent-of-the-linux-command-sudo-fdisk-l-in-macos">What is the equivalent of the Linux command “sudo fdisk -l” in MacOS?</a></p></blockquote><h2 id="mount命令的-o选项"><a href="#mount命令的-o选项" class="headerlink" title="mount命令的-o选项"></a>mount命令的-o选项</h2><p>这个命令相对比较复杂的地方可能就是这里了：首先，选项可以有很多个，用逗号分隔；其次，针对不同的文件系统，可能有一些特殊的选项，可以参考<a href="http://linux.die.net/man/8/mount">man mount</a>，里面用很长的篇幅说明了_mount options for xx_。</p><p>我们记住一下几个常用的就好了：</p><ul><li>修改已经_mount_的文件系统的属性：<em>remount</em></li><li>控制读写权限的：<em>rw_与_ro</em></li><li>控制执行权限的：<em>exec_与_noexec</em></li><li>控制执行权限的：_suid_与_nosuid_。允许和禁止set-user-identifier 或set-group-identifier位起作用</li><li>控制挂载和卸载权限的：_user_与_nouser_，_users_与_nousers_。前者是允许或禁止先前挂载该文件系统的用户挂载和卸载，后者是允许所有的用户挂载和卸载</li><li>控制文件系统的读写方式：<em>sync_与_async</em></li><li>防止用户读写某些系统关键数据：_dev_与_nodev_，如果需要深入了解，请阅读：<a href="http://superuser.com/questions/538550/understanding-mount-option-nodev-and-its-use-with-usb-flash-drives">Understanding mount option nodev and its use with USB flash drives</a></li><li>如果打开了文件，是否更新文件的访问时间：<em>atime_与_noatime</em></li><li>如果文件的访问时间比当前时间还早，是否更新访问时间：<em>relatime_与_norelatime</em></li><li><em>defaults_：默认选项，包括：_rw_，_suid_，_dev_，_exec_，_auto_，_nouser_，_async_以及_relatime</em></li></ul><blockquote><p>关于_set-user-identifier_详见：<a href="http://www.linuxnix.com/2011/12/suid-set-suid-linuxunix.html">What is SUID and how to set SUID in Linux/Unix?</a>，这篇文章中有几个例子，想必很容易理解了。</p></blockquote><h2 id="挂载远程文件系统"><a href="#挂载远程文件系统" class="headerlink" title="挂载远程文件系统"></a>挂载远程文件系统</h2><p>Linux和Linux之间文件共享，据我目前所知有两种方法：</p><ol><li>一种是基于NFS，参考：<a href="http://www.tecmint.com/how-to-setup-nfs-server-in-linux/">How to Setup NFS (Network File System) on RHEL/CentOS/Fedora and Debian/Ubuntu</a></li><li>另一种是基于SSH来挂在远程文件系统，称为sshfs，参考：<a href="http://www.howtogeek.com/howto/ubuntu/how-to-mount-a-remote-folder-using-ssh-on-ubuntu/">How to Mount a Remote Folder using SSH on Ubuntu</a></li></ol><p>链接中已经给出了具体的方法，此处不赘述，命令格式完全符合本文中提到的结构和参数，除了sshfs是使用_sshfs_命令，而不是_mount_命令。</p><pre><code>mount -t nfs 192.168.0.100:/nfsshare /mnt/nfssharesshfs share@192.168.0.100:/sshshare /mnt/sshshare</code></pre><h2 id="etc-fstab"><a href="#etc-fstab" class="headerlink" title="/etc/fstab"></a>/etc/fstab</h2><p>另外，<em>mount_还有一个参数是_mount -a_，这就不得不提一下Linux中的</em>/etc/fstab_文件和_/etc/mtab_文件。前者是系统启动时会自动挂载的文件系统的信息，后者是系统当前已挂载的文件系统信息。你会发现这个文件里面的配置基本和_mount_命令的参数一致。</p><pre><code>$ cat /etc/fstab# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;proc            /proc           proc    nodev,noexec,nosuid 0       0...$ cat /etc/mtabproc /proc proc rw,noexec,nosuid,nodev 0 0...</code></pre><p>不一样的地方是后面两个字段:</p><ol><li>_&lt;dump&gt;<em>告诉_dump_命令是否需要备份这个文件系统，上面例子中因为_proc_是一个<a href="http://baike.baidu.com/view/6096934.htm">伪文件系统，用于通过内核来访问进程信息</a>，因此不用备份，这个字段是_0</em></li><li>_&lt;pass&gt;<em>告诉</em><a href="http://baike.baidu.com/view/1757895.htm">fsck</a><em>命令是否需要在检查该文件系统，如果需要开机检查该文件系统，可以将这个字段设置为_1</em></li></ol><p>回到_mount -a_，一句话，此命令就是读取_/etc/fstab_，挂载里面的文件系统，一般Linux系统启动的时候会执行这个命令。</p><h2 id="Linux挂载Windows共享"><a href="#Linux挂载Windows共享" class="headerlink" title="Linux挂载Windows共享"></a>Linux挂载Windows共享</h2><p>一般情况下，可以通过下面这个命令来将Windows的共享挂载到Linux的文件系统中：</p><pre><code>mount -t cifs -o username=administrator,password=admin //192.168.0.1/share/ /mnt/windows</code></pre><p>_<a href="http://baike.baidu.com/view/1034390.htm">cifs</a><em>是微软实现的一种在Windows主机之间进行网络共享的协议。如果你需要在开机的时候自动挂载此文件系统，同样可以相应的配置写到</em>/etc/fstab_文件中。</p><h2 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h2><p>顾名思义，就是卸载文件系统。这个命令更加简单，参数可以是挂载点，也可以是磁盘名称，即下面两种方法均可：</p><pre><code>mount /dev/hda1 /mydocumount /dev/hda1umount /mydoc</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://linux.die.net/man/8/mount">mount(8) - Linux man page</a></li><li><a href="http://www.cnblogs.com/chengmo/archive/2010/10/13/1850515.html">linux mount挂载设备（u盘,光盘,iso等 ）使用说明</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;i&gt;mount&lt;/i&gt;命令在我心目中一直是个高大上的命令：首先，经常看见长度很长的&lt;i&gt;mount&lt;/i&gt;命令；其次，&lt;i&gt;mount&lt;/i&gt;是直接配置硬件的命令，敲命令的时候总是难免担心把机器搞挂了。因此，我一直以来在Mac OS和Ubuntu中都依靠操作系统自动检查插入的磁盘，就像在Windows里面一样，简直弱爆了。今天就抽空把整理一下这方面的知识。</summary>
    
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL查询优化：tmp_table_size与max_heap_table_size</title>
    <link href="http://zh-liang-cn.github.io/2014/04/18/mysql-tmp_table_size-max_heap_table_size/"/>
    <id>http://zh-liang-cn.github.io/2014/04/18/mysql-tmp_table_size-max_heap_table_size/</id>
    <published>2014-04-18T02:02:33.000Z</published>
    <updated>2021-10-30T16:18:49.734Z</updated>
    
    <content type="html"><![CDATA[<p>对于某些query，MySQL会创建临时表来进行处理，临时表有两种：</p><ul><li>基于<strong>MEMORY</strong>存储引擎的临时<strong>内存表</strong></li><li>基于<strong>MyISAM</strong>存储引擎的临时<strong>磁盘表</strong></li></ul><p>当临时<strong>内存表</strong>的大小达到一定限制的时候，MySQL就会将临时内存表写入到磁盘，变为临时<strong>磁盘表</strong>。</p><p>这个限制由<code>tmp_table_size</code>和<code>max_heap_table_size</code>这两个变量中的最小值确定。</p><blockquote><p>注意，用于使用<code>create table</code>创建的内存表和这里提到的临时内存表不一样，前者的大小仅仅只受<code>max_heap_table_size</code>来限制，而且永远不会出现超过大小限制会写入到磁盘。</p></blockquote><p>有这么几种情况会出现临时内存表：</p><ul><li>包含<code>UNION</code>的query；</li><li>使用了<code>UNION</code>或者聚合运算的视图，有个算法专门用于判定一个视图是不是会使用临时表：<a href="http://dev.mysql.com/doc/refman/5.0/en/view-algorithms.html">view-algorithms</a>；</li><li>如果query包含<code>order by</code>和<code>group by</code>子句，并且两个子句中的字段不一样；或者<code>order by</code>或者<code>group by</code>中包含除了第一张表中的字段；</li><li>query中同时包含<code>distinct</code>和<code>order by</code>。</li></ul><p>如果一个query的explain结果中的extra字段包含<code>using temporary</code>，说明这个query使用了临时表。</p><blockquote><p>使用explain的时候extra里面如果输出<code>using temporary;</code>说明需要使用临时表，但是这里无论如何都看不出来是不是使用了磁盘临时表（因为是不是使用磁盘临时表要根据query结果的大小来判定，在SQL分析阶段是无法判定的），<code>using filesort</code>是说没办法使用索引进行排序（<code>order by</code>和<code>group by</code>都需要排序），只能对输出结果进行quicksort，参考<a href="http://www.mysqlperformanceblog.com/2009/03/05/what-does-using-filesort-mean-in-mysql/">what-does-using-filesort-mean-in-mysql</a></p></blockquote><p>当MySQL处理query是创建了一个临时表（不论是内存临时表还是磁盘临时表），<code>created_tmp_tables</code>变量都会增加1。如果创建了一个磁盘临时表，<code>created_tmp_disk_tables</code>会增加1。<br>可以通过<code>show session status like &#39;Created_tmp_%&#39;;</code> 来查看，如果要查看全局的临时表使用次数，将其中的_session_改为_global_即可。<br>一般磁盘临时表会比内存临时表慢，因此要尽可能避免出现磁盘临时表。下面几种情况下，MySQL会直接使用磁盘内存表，要尽可能避免：</p><ul><li>表中包含了<code>BLOB</code>和<code>TEXT</code>字段（MEMORY引擎不支持这两种字段）；</li><li><code>group by</code>和<code>distinct</code>子句中的有超过512字节的字段；</li><li><code>UNION</code>以及<code>UNION ALL</code>语句中，如果<code>SELECT</code>子句中包含了超过512（对于binary string是512字节，对于character是512个字符）的字段。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.mysqlperformanceblog.com/2007/01/19/tmp_table_size-and-max_heap_table_size/">http://www.mysqlperformanceblog.com/2007/01/19/tmp_table_size-and-max_heap_table_size/</a></li><li><a href="http://dev.mysql.com/doc/refman/5.0/en/view-algorithms.html">http://dev.mysql.com/doc/refman/5.0/en/view-algorithms.html</a></li><li><a href="http://www.mysqlperformanceblog.com/2009/03/05/what-does-using-filesort-mean-in-mysql/">http://www.mysqlperformanceblog.com/2009/03/05/what-does-using-filesort-mean-in-mysql/</a></li></ul>]]></content>
    
    
    <summary type="html">对于某些query，MySQL会创建临时表来进行处理，临时表有两种：基于MEMORY存储引擎的临时内存表以及基于MyISAM存储引擎的临时磁盘表。当临时内存表的大小达到一定限制的时候，MySQL就会将临时内存表写入到磁盘，变为临时磁盘表。这个限制由tmp_table_size和max_heap_table_size这两个变量中的最小值确定。
</summary>
    
    
    
    <category term="MySQL" scheme="http://zh-liang-cn.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://zh-liang-cn.github.io/tags/MySQL/"/>
    
    <category term="Database" scheme="http://zh-liang-cn.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Linux dig 命令详解</title>
    <link href="http://zh-liang-cn.github.io/2014/02/12/dig-command-in-linux/"/>
    <id>http://zh-liang-cn.github.io/2014/02/12/dig-command-in-linux/</id>
    <published>2014-02-11T16:37:28.000Z</published>
    <updated>2021-10-30T16:18:49.723Z</updated>
    
    <content type="html"><![CDATA[<p>之所以会关注到这个命令，是因为最近在研究 <a href="http://zhouliang.pro/2014/01/19/mysql-master-slave-replication/">MySQL的主从复制</a> 相关的技术，希望能实现当Slave落后Master比较多的时候自动将Slave从数据源中去除掉的功能。找了很多资料，没有比较好的现成办法。只能参考 <a href="http://www.percona.com/software/percona-toolkit">percona-toolkit</a> 中的 <a href="http://www.percona.com/doc/percona-toolkit/2.1/pt-heartbeat.html">pt-heartbeat</a> 命令的实现自己来做，这个完全可以写另一篇博客了，暂且不提罢。</p><p>我们每台MySQL服务器都部署有监控用的程序，我希望把这个发送heartbeat的程序集成到监控程序中，但这个程序只需要在Master机器上启动，这就涉及到如何确定这台MySQL服务器是Master还是Slave了，有一些<a href="http://dba.stackexchange.com/questions/46011/how-to-determine-master-in-mysql-master-slave">办法</a>，但是都不算太好，因为MySQL的一个Slave机器也可以作为另一个Slave的Master，比较拗口，大意就是你的你的儿子也是你的孙子的爸爸。</p><p>好在我们的MySQL服务器都绑定着CNAME，访问一台MySQL服务器的时候，使用的是对应的CNAME，而不是那台机器的IP或者主机名（可以通过<code>hostname</code>命令查看，因此下文称为hostname），比如Master的机器是 <code>abcedfg.xxx.com</code>，但是我们另外绑定了<code>master.db.xxx.com</code> 域名，Slave机器是 <code>hijklmn.xxx.com</code>，我们绑定了 <code>slave-1.db.xxx.com</code> 域名。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;master&quot;</span> : <span class="string">&quot;master.db.xxx.com&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;slaves&quot;</span> : [<span class="string">&quot;slave-1.db.xxx.com&quot;</span>, <span class="string">&quot;slave-1.db.xxx.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我用了一个比较奇怪的方法：通过CNAME来查找Master的hostname，如果运行该heartbeat程序的机器的hostname和刚查找到的Master的hostname一致，则说明该程序运行于一台Master机器，否者就直接退出。</p><p>因此，问题转变成如何通过CNAME来查找一个域名其真正指向的服务器的hostname。这里，我直观的想到可以用Linux的<code>dig</code>命令来解决这个问题。需要注意的是，除了这个命令以外，很多编程语言库都提供相应的支持，比如Java的<a href="http://download.java.net/jdk7/archive/b123/docs/api/java/net/InetAddress.html">InetAddress</a>就可以实现<a href="http://stackoverflow.com/questions/3371879/ip-address-to-hostname-in-java">通过IP地址查找对应的域名</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InetAddress addr = InetAddress.getByName(<span class="string">&quot;8.8.8.8&quot;</span>);</span><br><span class="line">String host = addr.getHostName();</span><br><span class="line">System.out.println(host);</span><br></pre></td></tr></table></figure><h2 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h2><p>可能需要先大概介绍一下什么是CNAME：一个域名可以有两种类型的指向，如果一个<strong>域名指向</strong>称为一个<strong>记录（Record）</strong>的话，那么就有两种<strong>记录类型（Record Type）</strong>，分别是：</p><ul><li><strong>A记录</strong>：指向一个IP地址</li><li><strong>CNAME</strong>：指向一个其他的域名</li></ul><p>下面这个图是我的域名的配置：</p><p><a href="https://www.flickr.com/photos/zhlwish/14022922767/" title="Flickr 上 zhlwish 的 cname-settings"><img src="https://farm6.staticflickr.com/5080/14022922767_5176acafb9_o.png" width="793" height="166" alt="cname-settings"></a></p><p>这里有两条A记录，一条CNAME。两条A记录指向的就是我的博客所在的VPS：</p><ul><li>第二条容易理解，就是将 <code>www.zhouliang.pro</code> 指向了VPS的IP地址，这样你使用 <code>http://www.zhouliang.pro</code> 就可以访问我的博客了；</li><li>第一条有点奇怪，这里是一个泛域名，也就是将 <code>zhouliang.pro</code> 也指向了这个IP地址，也就是说你用 <code>http://zhouliang.pro</code> 也可以直接访问我的博客。</li><li>第三条记录就是一个CNAME指向，也许你已经在浏览器中打开了 <code>http://i.zhouliang.pro</code> ，我将 <code>i.zhouliang.pro</code> 转向了网易轻博客服务，放了几张照片，你们感受一下，小清新有木有。</li></ul><blockquote><p>彩蛋：买域名的时候特别注意服务商是不是提供免费的泛域名解析服务，不提供的都是耍流氓，据我所知，万网就是在耍流氓。</p></blockquote><h2 id="dig-命令"><a href="#dig-命令" class="headerlink" title="dig 命令"></a>dig 命令</h2><p>学习Linux命令只有一条路，那就是：<code>man dig</code>，到控制台敲一下这个命令，输出略长。本文的目的是先大致介绍一下，深入了解还是得细读<code>man dig</code>。<br>在控制台输入，输出结果如下：</p><pre><code>$ dig i.zhouliang.pro; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; i.zhouliang.pro;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 45515;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;i.zhouliang.pro.       IN  A;; ANSWER SECTION:i.zhouliang.pro.        14400   IN  CNAME   mydomain.lofter.com.mydomain.lofter.com.    18000   IN  A       54.248.125.234;; Query time: 211 msec;; SERVER: 192.168.106.1#53(192.168.106.1);; WHEN: Fri Jan 24 00:43:26 2014;; MSG SIZE  rcvd: 82</code></pre><p>输出结果大致分成4个部分，实际上可能还包括更多的内容，总共会有以下6个部分：</p><ol><li><strong>Header</strong>: 包括软件版本，全局变量以及除消息头以外的其他部分的信息，比如上例中，显示有1个QUERY，2个ANSWER</li><li><strong>QUESTION SECTION</strong>: 请求参数信息，也就是你的输入</li><li><strong>ANSWER SECTION</strong>: 从DNS查询到的信息，也就是输出，显示<code>i.zhouliang.pro</code>是CNAME，指向<code>mydomain.lofter.com</code>，而后者是一个A记录，指向一个IP地址</li><li><strong>AUTHORITY SECTION</strong>: 包含DNS域名服务器的授权信息，上例中不包含这一部分，如果用这个命令就可以看到 <code>dig @ns1.redhat.com redhat.com</code> ，这里的<code>@</code>符号用于指定查询所使用的DNS服务器</li><li><strong>ADDITIONAL SECTION</strong>: 包含AUTHORITY SECTION中的域名服务器的IP地址，同样，上例中也不包含这一部分</li><li><strong>Stats section</strong>: 最下方的一部分，显示了查询时间等额外信息</li></ol><p>另外，上面所有的以 <code>;</code> 开头的行实际上都是注释。<br>可以通过下面的参数来控制显示或者不显示上面的这些部分：</p><ol><li>+nocomments :  不显示注释</li><li>+noauthority :  不显示AUTHORITY SECTION</li><li>+noadditional :  不显示ADDITIONAL SECTION</li><li>+nostats :  不显示Stats section</li><li>+noanswer :  不显示ANSWER SECTION</li><li>+noall : 不显示所有的信息，一般会这样用 <code>dig zhouliang.pro +noall +answer</code></li></ol><p>和上面参数对应还有<code>+comments</code>，<code>+answer</code>等，后文有示例，此处不赘述。另外，还有如下两个参数需要了解：</p><ul><li>+short : 显示简短的信息</li><li>-t &lt;type&gt; : 指定查询的记录类型，可以是CNAME、A、MX、NS，分别表示CNAME、A记录、MX记录、DNS服务器，默认是A</li><li>-x : 表示反向查找，也就是根据IP地址查找域名</li></ul><h2 id="dig命令示例"><a href="#dig命令示例" class="headerlink" title="dig命令示例"></a>dig命令示例</h2><p>下面来举几个实用的例子。</p><h3 id="查看域名"><a href="#查看域名" class="headerlink" title="查看域名"></a>查看域名</h3><pre><code>$ dig i.zhouliang.pro +noall +anwser; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; i.zhouliang.pro +noall +answer;; global options: +cmdi.zhouliang.pro.            10034    IN    CNAME    mydomain.lofter.com.mydomain.lofter.com.        9183     IN    A        54.248.125.234</code></pre><p>特别注意这里输出了两行，第一行是CNAME，先将<code>i.zhouliang.pro</code>解析成<code>mydomain.lofter.com</code>，第二行是A记录，将<code>mydomain.lofter.com</code>解析成IP地址。这是一个完整的域名解析过程。</p><h3 id="查找域名的MX记录："><a href="#查找域名的MX记录：" class="headerlink" title="查找域名的MX记录："></a>查找域名的MX记录：</h3><pre><code>$ dig zhouliang.pro -t MX +short10 mxdomain.qq.com.</code></pre><p>从输出可以看出，我用了QQ提供的域名邮箱服务。</p><h3 id="查找域名对应的CNAME："><a href="#查找域名对应的CNAME：" class="headerlink" title="查找域名对应的CNAME："></a>查找域名对应的CNAME：</h3><pre><code>$ dig i.zhouliang.pro -t CNAME +shortmydomain.lofter.com.</code></pre><p>从输出可以看出，我用了网易Loft提供的博客服务。另外，这个方法刚好解答了本文开头所提到的那个问题。</p><h3 id="根据IP地址反向查找域名"><a href="#根据IP地址反向查找域名" class="headerlink" title="根据IP地址反向查找域名"></a>根据IP地址反向查找域名</h3><pre><code>$ dig -x 8.8.8.8 +short; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; -x 8.8.8.8 +noall +answer;; global options: +cmd8.8.8.8.in-addr.arpa.    79605    IN    PTR    google-public-dns-a.google.com.</code></pre><p>从输出可以看出，Google的这个DNS服务器有个域名叫做google-public-dns-a.google.com</p><h3 id="查询域名的解析DNS服务器地址"><a href="#查询域名的解析DNS服务器地址" class="headerlink" title="查询域名的解析DNS服务器地址"></a>查询域名的解析DNS服务器地址</h3><pre><code>$ dig zhouliang.pro ns +shortns15.bigwww.com.ns13.bigwww.com.</code></pre><p>从输出可以找到我的解析我的域名的DNS服务器地址。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.thegeekstuff.com/2012/02/dig-command-examples/">10 Linux DIG Command Examples for DNS Lookup</a></li></ul>]]></content>
    
    
    <summary type="html">之所以会关注到这个命令，是因为最近在研究 &lt;a href=&quot;http://zhouliang.pro/2014/01/19/mysql-master-slave-replication/&quot;&gt;MySQL的主从复制&lt;/a&gt; 相关的技术，希望能实现当Slave落后Master比较多的时候自动将Slave从数据源中去除掉的功能。找了很多资料，没有比较好的现成办法。只能参考 &lt;a href=&quot;http://www.percona.com/software/percona-toolkit&quot;&gt;percona-toolkit&lt;/a&gt; 中的 &lt;a href=&quot;http://www.percona.com/doc/percona-toolkit/2.1/pt-heartbeat.html&quot;&gt;pt-heartbeat&lt;/a&gt; 命令的实现自己来做，在实现的过程中，发现这个`dig`命令，深感有必要记录一下。
</summary>
    
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/categories/Linux/"/>
    
    
    <category term="MySQL" scheme="http://zh-liang-cn.github.io/tags/MySQL/"/>
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>令牌桶算法/Token Bucket Algorithm</title>
    <link href="http://zh-liang-cn.github.io/2014/01/25/token-bucket-algorithm/"/>
    <id>http://zh-liang-cn.github.io/2014/01/25/token-bucket-algorithm/</id>
    <published>2014-01-24T17:40:56.000Z</published>
    <updated>2021-10-30T16:18:49.739Z</updated>
    
    <content type="html"><![CDATA[<p>在电信网络中最常用的<strong>流量控制算法</strong>就是 <a href="http://en.wikipedia.org/wiki/Token_bucket">令牌桶算法</a>（Token Bucket Algorithm），在Linux上同样也用了这个算法来 <a href="http://lartc.org/howto/lartc.qdisc.classless.html#AEN690">对带宽进行管理</a>。当然使用场景不仅仅局限于此，凡是涉及到流量控制的地方都可以使用这种方法。例如，我们可以用这种方法对Web Service的访问量进行控制，可以避免Web Service遭受到恶意的攻击，也可以实现较复杂的流量分级计费，比如：调用次数1000次/s以下，每天收费10元；1000-2000次/s以下，每天收费40元等。</p><p><a href="http://en.wikipedia.org/wiki/Token_bucket">令牌桶算法</a> 实际上由三部分组成：两个流和一个桶，分别是令牌流、数据流与令牌桶。</p><h2 id="令牌流与令牌桶"><a href="#令牌流与令牌桶" class="headerlink" title="令牌流与令牌桶"></a>令牌流与令牌桶</h2><p>系统会以一定的速度生成令牌，并将其放置到令牌桶中，可以将令牌桶想象成一个缓冲区（可以用队列这种数据结构来实现），当缓冲区填满的时候，新生成的令牌会被扔掉。<br>这里有两个变量很重要：</p><ul><li>第一个是生成令牌的速度，一般称为 <em>rate</em> 。比如，我们设定 _rate = 2_，即每秒钟生成 <em>2</em> 个令牌，也就是每 <em>1/2</em> 秒生成一个令牌； </li><li>第二个是令牌桶的大小，一般称为 _burst_。比如，我们设定 _burst = 10_，即令牌桶最大只能容纳 <em>10</em> 个令牌。</li></ul><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>数据流是真正的进入系统的流量，对于Web Service来讲，如果平均每秒钟会调用2次，则认为速率为 <em>2次/s</em> 。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>系统接收到一个单位数据（对于网络传输，可以是一个包或者一个字节；对于Web Service，可以是一个请求）后，从令牌桶中取出一个令牌，然后对数据或请求进行处理。如果令牌桶中没有令牌了，会直接将数据或者请求丢弃。当然，对于Web Service，就不能是丢弃这么简单了：可以返回一个异常消息，用于提示用户其请求速率超过了系统限制。<br>整个算法的结构看起来是这样：</p><p><a href="https://www.flickr.com/photos/zhlwish/14206222001/" title="Flickr 上 zhlwish 的 token-bucket"><img src="https://farm3.staticflickr.com/2908/14206222001_9729125a30_o.png" width="851" height="311" alt="token-bucket"></a></p><p>有一下三种情形可能发生：</p><ul><li>数据流的速率 <strong>等于</strong> 令牌流的速率。这种情况下,每个到来的数据包或者请求都能对应一个令牌,然后无延迟地通过队列；</li><li>数据流的速率 <strong>小于</strong> 令牌流的速率。通过队列的数据包或者请求只消耗了一部分令牌，剩下的令牌会在令牌桶里积累下来，直到桶被装满。剩下的令牌可以在突发请求的时候消耗掉。</li><li>数据流的速率 <strong>大于</strong> 令牌流的速率。这意味着桶里的令牌很快就会被耗尽。导致服务中断一段时间，如果数据包或者请求持续到来,将发生丢包或者拒绝响应。</li></ul><p>比如前面举的例子，生成令牌的速率和令牌桶的大小分别为 _rate = 2, burst = 10_，则系统能承受的突发请求速率为 _10次/s_，平均请求速率为 _2次/s_。<br>三种情形中的最后一种情景是这个算法的核心所在，这个算法非常精确，实现非常简单并且对服务器的压力可以忽略不计，因此应用得相当广泛，值得学习和利用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://lartc.org/#download">Linux 的高级路由和流量控制/Linux Advanced Routing &amp; Traffic Control</a></li><li><a href="http://en.wikipedia.org/wiki/Token_bucket">Token Bucket from WikiPedia</a></li></ul>]]></content>
    
    
    <summary type="html">在电信网络中最常用的流量控制算法是 &lt;a href=&quot;http://en.wikipedia.org/wiki/Token_bucket&quot;&gt;令牌桶算法&lt;/a&gt;（Token Bucket Algorithm），在Linux上同样也用了这个算法来 &lt;a href=&quot;http://lartc.org/howto/lartc.qdisc.classless.html#AEN690&quot;&gt;对带宽进行管理&lt;/a&gt;。当然使用场景不仅仅局限于此，凡是涉及到流量控制的地方都可以使用这种方法。例如，我们可以用这种方法对Web Service的访问量进行控制，可以避免Web Service遭受到恶意的攻击，也可以实现较复杂的流量分级计费，比如：调用次数1000次/s以下，每天收费10元；1000-2000次/s以下，每天收费40元等。
</summary>
    
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/tags/Linux/"/>
    
    <category term="Algorithm" scheme="http://zh-liang-cn.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Master-Slave Replication / 主从复制</title>
    <link href="http://zh-liang-cn.github.io/2014/01/19/mysql-master-slave-replication/"/>
    <id>http://zh-liang-cn.github.io/2014/01/19/mysql-master-slave-replication/</id>
    <published>2014-01-19T10:11:31.000Z</published>
    <updated>2021-10-30T16:18:49.731Z</updated>
    
    <content type="html"><![CDATA[<p>通过MySQL主从复制（Master-Slave）来实现读写分离是一种常用的扩展方法：所有的写操作通过Master完成，所有的读操作通过Slave来完成，也可以设置一主多从，或者双主的方式来实现负载均衡，极大的增强了MySQL的可扩展性。我所在的Team也是通过MySQL的这种主从复制的结构来扩展MySQL的性能的，不过，我并没有参与搭建这个平台，本文是我在业余进行的自学结果（不管你有没有读出来，这里的言外之意就是按照我这里搞如果搞出问题来了，我是不负责的）。</p><h2 id="MySQL主从复制的实现原理"><a href="#MySQL主从复制的实现原理" class="headerlink" title="MySQL主从复制的实现原理"></a>MySQL主从复制的实现原理</h2><p>先上张图，非常经典的图：</p><p><a href="https://www.flickr.com/photos/zhlwish/14209516325/" title="Flickr 上 zhlwish 的 mysql-master-slave-replication"><img src="https://farm6.staticflickr.com/5274/14209516325_b71b337f96_o.png" width="507" height="320" alt="mysql-master-slave-replication"></a></p><p>总结起来有这么4个步骤：</p><ul><li>Slave上面的_I/O thread_连接上Master，并请求从指定日志文件的指定位置(或者从最开始的日志)之后的日志内容;</li><li>Master接收到来自Slave的_I/O thread_的请求后，通过负责复制的_I/O thread_根据请求信息读取指定日志指定位置之后的日志信息，返回给 Slave端的_I/O thread_。返回信息中除了日志所包含的信息之外，还包括本次返回的信息在Master端的Binary Log文件的名称以及在Binary Log（一般是mysql-bin.xxxxxx）中的位置;</li><li>Slave的_I/O thread_接收到信息后，将接收到的日志内容依次写入到Slave端的Relay Log文件（一般是mysql-relay-bin.xxxxxx）的最末端，并将读取到的Master端的Binary Log的文件名和位置记录到<code>master.info</code>文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个Binary Log的哪个位置开始往后的日志内容，请发给我”；</li><li>Slave 的_SQL thread_检测到Relay Log中新增加了内容后，会马上解析该Log文件中的内容成为在Master端真实执行时候的可执行的Query语句，并在自身执行这些Query。这样，实际上就是在Master端和Slave端执行了同样的Query，所以两端的数据是完全一样的。</li></ul><h2 id="MySQL主从复制的搭建"><a href="#MySQL主从复制的搭建" class="headerlink" title="MySQL主从复制的搭建"></a>MySQL主从复制的搭建</h2><p>下面的步骤参考了MySQL官方的<a href="http://dev.mysql.com/doc/refman/5.5/en/replication.html">MySQL 5.5 Reference Manual :: 16 Replication</a>，顺便吐槽一下,这个手册写的组织结构实在有点乱。</p><h3 id="1-配置MySQL-Master"><a href="#1-配置MySQL-Master" class="headerlink" title="1. 配置MySQL Master"></a>1. 配置MySQL Master</h3><p>首先，打开Master的Binary Log功能，修改Master服务器的<strong>my.cnf</strong>文件:</p><pre><code>[mysqld]log-bin=mysql-binserver-id=1</code></pre><p>有三点需要注意的是：</p><ul><li><code>server-id</code>在整个Replication Group（即所有的Master和Slave服务器）里面必须是唯一的;</li><li>如果你使用了InnoDB，可以启用<code>innodb_flush_log_at_trx_commit=1</code>和<code>sync_binlog=1</code>，第一个参数指定每次事务提交后都需要将内存缓冲中的临时Log写入到硬盘上，第二个参数指定在事务提交后立即将内存缓冲中的临时Binary Log写入到硬盘上。通过指定这两个参数可以提高_Durability_和_Consistency_，不过却牺牲了性能，详见 <a href="http://wzmtony.blog.163.com/blog/static/20318015620130171834386/">MySQL的innodb_flush_log_at_trx_commit配置值的设定</a> 和 <a href="http://www.cnblogs.com/Cherie/p/3309503.html">Mysql配置参数sync_binlog说明</a>；</li><li><code>skip-networking</code>这一行必须注释掉，不然无法通过网络连接MySQL服务器。</li></ul><p>本文前面提到，Slave的_I/O thread_会连接到Master上读取Binary Log，因此需要设定一个用户名和密码，原则上这里可以使用任何一个MySQL用户名。但是考虑到Slave会将这个用户名和密码用明文的方式保存在<code>data/master.info</code>文件中，不太安全。因此一般创建一个独立的账户，并且使这个账户只有<code>replication slave</code>的权限。</p><p>用MySQL客户端连接Master上，执行下面语句，在Master上创建一个账户，并赋予<code>replication slave</code>的权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;replication_user&#x27;</span>@<span class="string">&#x27;%.xxx.com&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;replication_password&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;replication_user&#x27;</span>@<span class="string">&#x27;%.xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果执行上面的语句的时候出现这样的错误：</p><pre><code>ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;%&#39; (using password: YES)</code></pre><p>可能是你所使用的账户没有<code>grant option</code>权限。出于安全的考虑，有些MySQL服务器可能禁用了不是从_localhost_进行连接的<code>grant option</code>的权限，到MySQL服务器上，用<code>root</code>建立连接，并执行下面的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">GRANT</span> OPTION <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>然后重新在执行之前的<code>grant</code>语句。所有配置完成后，重启MySQL Master服务器。</p><h3 id="2-配置MySQL-Slave"><a href="#2-配置MySQL-Slave" class="headerlink" title="2. 配置MySQL Slave"></a>2. 配置MySQL Slave</h3><p>修改Slave服务器的<strong>my.cnf</strong>文件，只需要将<code>server-id</code>配置得和Master不一样即可:</p><pre><code>[mysqld]server-id=2</code></pre><p>配置完成后重启MySQL Slave服务器。</p><p>注意，在Salve上可以不启用Binary Log，不过启用了有两方面用处：</p><ul><li>作为备份，可以从Slave定期备份Binary Log，不用增加Master的负担；</li><li>可以将Slave配置成其他MySQL实例的Master，实现更复杂的拓扑结构（Topology）。</li></ul><h3 id="3-复制数据"><a href="#3-复制数据" class="headerlink" title="3. 复制数据"></a>3. 复制数据</h3><p>如果不能允许数据库宕机，或者数据量不算太大，可以用<code>mysqldump</code>完整备份整个数据库：</p><pre><code>mysqldump --all-databases --master-data &gt; dbdump.sql</code></pre><p>注意，这里如果指定了<code>--master-data</code>，在备份文件中会自动生成这样的语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;mysqld-bin.xxxxxx&#x27;</span>, MASTER_LOG_POS<span class="operator">=</span>xxx;</span><br></pre></td></tr></table></figure><p>如果不指定这个参数，就必须先执行下面语句来对整个数据库加读锁。对于InnoDB，这会阻塞所有的写操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush <span class="keyword">table</span> <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p>来查看并记录当前的Binary Log文件的名称和位置，然后在Slave上导入数据的时候（即本文的下一步）手动执行上面的<code>change master to ...</code>语句。</p><p>当然最后需要执行下面的语句来释放之前加在数据库上的读锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h3 id="4-在Slave导入数据，启动Slave"><a href="#4-在Slave导入数据，启动Slave" class="headerlink" title="4. 在Slave导入数据，启动Slave"></a>4. 在Slave导入数据，启动Slave</h3><p>连接到Slave上，执行下面的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset slave;</span><br><span class="line">change master <span class="keyword">to</span></span><br><span class="line">   master_host <span class="operator">=</span> <span class="string">&#x27;your master host&#x27;</span>,</span><br><span class="line">   master_user <span class="operator">=</span> <span class="string">&#x27;replication_user&#x27;</span>,</span><br><span class="line">   master_password <span class="operator">=</span> <span class="string">&#x27;replication_password&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在控制台中执行下面命令向Slave中导入Master的数据：</p><pre><code>msyql -u root -p &lt; dbdump.sql</code></pre><p>完成后，用MySQL客户端连接到Slave上，执行下面命令启动Slave的I/O thread和SQL thread：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure><p>完成后，可以通过下面这个命令来检查Slave的状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status;</span><br></pre></td></tr></table></figure><p>如果<code>Slave_IO_Running</code>和<code>Slave_SQL_Running</code>列的值都是<code>Yes</code>，就看起来正常了，这时你可以尝试在Master上创建一张表，然后在Slave上检查，你会发现这个表在Slave上也出现了。<br>我在配置的时候发现<code>Slave_SQL_Running = No</code>，而且<code>Last_Error</code>列出现了一个错误。后来发现是我在配置的时候没有在Slave上执行<code>stop slave; reset slave;</code>这两个语句导致的。当然也可以在启动Salve的时候指定<code>--skip-slave-start</code>参数。</p><blockquote><p>2014-02-20更新：如果<code>Last_Error</code>列出现的错误是<code>Could not execute Delete_rows event on table</code> 或者<code>Could not execute Update_rows event on table</code>等，这表示Master上删除了一条在Slave上并不存在的行，这种情况一般不会发生，除非无关紧要的数据不一致。解决这种问题的方法是在Slave上执行：<code>STOP SLAVE; SET SQL_SLAVE_SKIP_COUNTER=1; START SLAVE;</code>，直接忽略这个错误。但是这种方法显然不好，请参考<a href="http://www.mysqlperformanceblog.com/2013/07/23/another-reason-why-sql_slave_skip_counter-is-bad-in-mysql/">Another reason why SQL_SLAVE_SKIP_COUNTER is bad in MySQL</a>。</p></blockquote><h2 id="离线复制数据"><a href="#离线复制数据" class="headerlink" title="离线复制数据"></a>离线复制数据</h2><p>除了使用<code>mysqldump</code>命令来实现从Master拷贝数据到Slave上以外，还可以直接打包整个Master的<code>data</code>目录并复制Slave上来实现，详见 <a href="http://dev.mysql.com/doc/refman/5.5/en/replication-howto-rawdata.html">Creating a Data Snapshot Using Raw Data Files</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://dev.mysql.com/doc/refman/5.5/en/replication.html">MySQL 5.5 Reference Manual :: 16 Replication</a></li><li><a href="http://tech.it168.com/a2009/0526/577/000000577294.shtml">MySQL Replication的实现原理</a></li><li><a href="http://www.cnblogs.com/hustcat/archive/2009/12/19/1627525.html">理解MySQL–复制(Replication)</a></li><li><a href="http://blog.csdn.net/wlzjsj/article/details/8032493">mysql主从复制搭建中几种log和pos详解</a></li><li><a href="http://blog.longwin.com.tw/2008/03/mysql_replication_master_slave_set_2008/">MySQL 設定 Replication (Master - Slave)</a></li></ul>]]></content>
    
    
    <summary type="html">通过MySQL主从复制（Master-Slave）来实现读写分离是一种常用的扩展方法：所有的写操作通过Master完成，所有的读操作通过Slave来完成，也可以设置一主多从，或者双主的方式来实现负载均衡，极大的增强了MySQL的可扩展性。我所在的Team也是通过MySQL的这种主从复制的结构来扩展MySQL的性能的，不过，我并没有参与搭建这个平台，本文是我在业余进行的自学结果（不管你有没有读出来，这里的言外之意就是按照我这里搞如果搞出问题来了，我是不负责的）。
</summary>
    
    
    
    <category term="MySQL" scheme="http://zh-liang-cn.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://zh-liang-cn.github.io/tags/MySQL/"/>
    
    <category term="Database" scheme="http://zh-liang-cn.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Vim的Window/窗口</title>
    <link href="http://zh-liang-cn.github.io/2014/01/13/vim-window/"/>
    <id>http://zh-liang-cn.github.io/2014/01/13/vim-window/</id>
    <published>2014-01-12T17:09:51.000Z</published>
    <updated>2021-10-30T16:18:49.743Z</updated>
    
    <content type="html"><![CDATA[<p>Vim实际上是一个<strong>多窗口</strong>的编辑器，启动Vim后实际上默认只打开了一个窗口，如果需要在编辑当前文件的时候参考其他的文件，就需要使用到多窗口了。</p><p>Vim窗口中打开的是一个Vim缓冲区（Buffer），请参考我的另一篇博客<a href="http://zhouliang.pro/2012/06/28/vim-buffer/">Vim的Buffer/缓冲区</a>，实际上也可以说不谈<strong>窗口</strong>而只谈<strong>缓冲区</strong></p><p>是不负责任的，因此就有了这篇小短文。额外提一下，Vim中的标签页（Tab）可以包含多个窗口，不像我们常用的<a href="http://www.eclipse.org">Eclipse</a>、<a href="http://macromates.com/">TextMate</a>或者<a href="http://www.sublimetext.com/">Sublime</a>等编辑器，一个标签页只是对应一个窗口。</p><blockquote><p>学习一个工具，也要学习其背后的设计原理和设计哲学。</p></blockquote><h2 id="打开-关闭窗口"><a href="#打开-关闭窗口" class="headerlink" title="打开/关闭窗口"></a>打开/关闭窗口</h2><p>打开文件的时候，可以用 <code>vim file1 file2 file3</code> 命令一次性打开多个文件，不过Vim默认只会打开一个窗口，显示的第一个文件<code>file1</code>对应的Buffer（注意这句话的表达，显示的不是文件<code>file1</code>本身，而是<code>file1</code>文件对应的Buffer）。其他两个文件对应的Buffer处于_hidden_的状态<br>如果加上<code>-o</code>或者<code>-O</code>参数，Vim就为每个Buffer打开一个窗口，如果是<code>-o</code>则窗口会从上到下排列，如果是<code>-O</code>则窗口从左到右排列。</p><pre><code>vim -o file1 file2 file3</code></pre><p>打开的窗口排列方式如下图所示，读者可以自行尝试大写的<code>-O</code>参数。</p><p><a href="https://www.flickr.com/photos/zhlwish/14022883140/" title="Flickr 上 zhlwish 的 vim-window-vertical"><img src="https://farm6.staticflickr.com/5039/14022883140_34ba4f36f0_o.png" width="641" height="382" alt="vim-window-vertical"></a></p><p>也可以在Vim启动后自行创建新窗口，<code>:new</code>命令和<code>:split</code>命令都可以实现这样的功能，其区别在与前者是打开一个空的缓冲区，后者会打开当前所在窗口对应的缓冲区，也就是说拆分后的窗口和原来的窗口内容一样。<br>这两个命令都会将当前窗口拆分成上下排列的两个窗口，因此还有<code>:vnew</code>和<code>:vsplit</code>两个命令可以将当前窗口拆分成左右排列的窗口。</p><p>另外，快捷键<code>Ctrl+w+s</code>和<code>Ctrl+w+v</code>分别对应<code>:split</code>和<code>:vsplit</code>命令。</p><p>打开窗口后，可以使用<code>:q</code>来退出窗口，用<code>:w</code>来保存窗口显示的缓冲区中的内容，这和平常是一样的。也可以使用<code>ZZ</code>或者<code>Ctrl+w+c</code>快捷键或者<code>:hide</code>命令来关闭当前窗口，<code>Ctrl+w+o</code>快捷键或者<code>:only</code>命令可以关闭当前窗口外的其他所有窗口，在很多其他编辑器的标签页上点击右键都可以找到这个功能。</p><h2 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h2><p>虽然可以有多个窗口，当时处于激活状态的窗口只能有一个。可以使用<code>Ctrl+w+w</code>快捷键在多个窗口中来回切换，也可以使用<code>Ctrl+w</code>再加上上下左右键的来在不同的窗口中切换。<br><code>Ctrl+w+j</code>可以切换到下一个窗口中，<code>Ctrl+w+k</code>可以将切换到在上一个窗口中，<code>Ctrl+w+t</code>可以直接切换到最顶部的窗口，<code>Ctrl+w+b</code>可以直接切换到最底部的窗口，而<code>Ctrl+w+p</code>可以切换到最近一次所在的窗口。</p><h2 id="移动窗口"><a href="#移动窗口" class="headerlink" title="移动窗口"></a>移动窗口</h2><p>说实在话，我使用Vim的经历中很少用到移动窗口的功能，列在这里只是保证这篇短文的完整性而已，所以你要是记不住这些命令就直接跳过好了，直接到下面_调整窗口大小_一节，这个功能非常常用。</p><p>快捷键<code>Ctrl+w+r</code>可以将当前的窗口向下进行循环移动。这个命令可以带一个数字作为参数，指明向下循环移动所执行的次数。对应的有<code>Ctrl+w+R</code>快捷键，可以使得窗口向上循环移动。</p><p>快捷键<code>Ctrl+w+x</code>可以将当前窗口与下一窗口进行位置对换。如果当前窗口在底部，而且没有下一个窗口，这个快捷键将使当前窗口与上一个窗口进行位置对换。 利用<code>Ctrl+w+K</code>可以将当前窗口放到最顶端，而<code>Ctrl+w+J</code>可以把当前窗口放到最底部。</p><h2 id="调整窗口大小"><a href="#调整窗口大小" class="headerlink" title="调整窗口大小"></a>调整窗口大小</h2><p>快捷键<code>Ctrl+w+&gt;</code>可以增加窗口的宽度，快捷键<code>Ctrl+w+&lt;</code>可以减少窗口的宽度，快捷键<code>Ctrl+w++</code>可以增加窗口的高度，快捷键<code>Ctrl+w+-</code>可以减少窗口的高度，这几个快捷键都很形象。需要注意的是<code>Ctrl+w+&gt;</code>和<code>Ctrl+w+&lt;</code>只会增加或者减少一个单位，基本毫无用处，可以考虑使用<code>10 Ctrl+w+&gt;</code>将宽度增加10个单位，其他的可以以此类推，详见 <a href="http://stackoverflow.com/questions/4368690/how-to-increase-the-vertical-split-window-size-in-vim">How to increase the vertical split window size in Vim</a>。</p><p>快捷键<code>Ctrl+w+=</code>可以使窗口的宽度或者高度变成相同。</p><p>最后，这个快捷键<code>Ctrl+W+_</code>可以将当前的窗口最大化，是不是挺有意思的。:)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.cs.swarthmore.edu/help/vim/windows.html">http://www.cs.swarthmore.edu/help/vim/windows.html</a></li><li><a href="http://www.pythonclub.org/linux/vim/window">http://www.pythonclub.org/linux/vim/window</a></li><li><a href="http://stackoverflow.com/questions/4368690/how-to-increase-the-vertical-split-window-size-in-vim">http://stackoverflow.com/questions/4368690/how-to-increase-the-vertical-split-window-size-in-vim</a></li><li><a href="http://www.cs.swarthmore.edu/help/vim/windows.html">http://www.cs.swarthmore.edu/help/vim/windows.html</a></li></ul>]]></content>
    
    
    <summary type="html">Vim实际上是一个多窗口的编辑器，启动Vim后实际上默认只打开了一个窗口，如果需要在编辑当前文件的时候参考其他的文件，就需要使用到多窗口了。Vim窗口中打开的是一个Vim缓冲区（Buffer），请参考我的另一篇博客&lt;a href=&quot;http://zhouliang.pro/2012/06/28/vim-buffer/&quot;&gt;Vim的Buffer/缓冲区&lt;/a&gt;，实际上也可以说不谈窗口而只谈缓冲区是不负责任的，因此就有了这篇小短文。额外提一下，Vim中的标签页（Tab）可以包含多个窗口，不像我们常用的&lt;a href=&quot;http://www.eclipse.org&quot;&gt;Eclipse&lt;/a&gt;、&lt;a href=&quot;http://macromates.com/&quot;&gt;TextMate&lt;/a&gt;或者&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime&lt;/a&gt;等编辑器，一个标签页只是对应一个窗口。学习一个工具，也要学习其背后的设计原理和设计哲学。
</summary>
    
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/tags/Linux/"/>
    
    <category term="Vim" scheme="http://zh-liang-cn.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>MySQL删除表的时候忽略外键约束</title>
    <link href="http://zh-liang-cn.github.io/2013/12/18/mysql-drop-table-ignore-foreign-key-constraints/"/>
    <id>http://zh-liang-cn.github.io/2013/12/18/mysql-drop-table-ignore-foreign-key-constraints/</id>
    <published>2013-12-18T00:10:11.000Z</published>
    <updated>2021-10-30T16:18:49.730Z</updated>
    
    <content type="html"><![CDATA[<p>删除表不是特别常用，特别是对于存在外键关联的表，删除更得小心。但是在开发过程中，发现Schema设计的有问题而且要删除现有的数据库中所有的表来重新创建也是常有的事情；另外在测试的时候，也有需要重新创建数据库的所有表。当然很多自动化工具也可以做这样的事情。</p><p>删除表的时候有时会遇到这样的错误消息：</p><pre><code>ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint fails</code></pre><p>这是因为你尝试删除的表中的字段被用作了其他表的外键，因此在删除这个表（父表）之前必须先删除具有外键的表（子表）。也就是说，删除表的过程需要和创建表的过程一致。</p><p>但是这往往不可接受，一方面如果表太多了，手动排序有点不可接受；另一方面，现在还没有自动的工具对进行排序（其实也不是不能实现）。因此，MySQL中提供了一个变量<code>FOREIGN_KEY_CHECKS</code>来设置是否在必要的时候检查外键约束。一般比较推荐这样做：</p><p>首先，自动生成所有的DROP语句，将其中的<code>MyDatabaseName</code>替换成你的数据库名称：</p><pre><code class="sql">SELECT concat(&#39;DROP TABLE IF EXISTS &#39;, table_name, &#39;;&#39;)FROM information_schema.tablesWHERE table_schema = &#39;MyDatabaseName&#39;;&#123;% endhighlight%&#125;然后，在生成的代码前后添加下面设置`FOREIGN_KEY_CHECKS`变量的语句：```sqlSET FOREIGN_KEY_CHECKS = 0-- DROP语句SET FOREIGN_KEY_CHECKS = 1;&#123;% endhighlight%&#125;不过，要是忘记了最后一句也没太大关系，这个变量是基于Session的，也就是说，当你关闭了客户端，重新建立连接的时候，这个变量会恢复默认值。如果需要在全局范围内不检查外键约束（这种情况会比较少吧），可以这样做：```sqlSET GLOBAL FOREIGN_KEY_CHECKS = 0;&#123;% endhighlight%&#125;或者```sqlset @@global.FOREIGN_KEY_CHECKS = 0;&#123;% endhighlight%&#125;## 参考：* &lt;a href=&quot;http://stackoverflow.com/questions/8538636/mysql-set-foreign-key-checks&quot;&gt;mysql SET FOREIGN_KEY_CHECKS&lt;/a&gt;* &lt;a href=&quot;http://stackoverflow.com/questions/3476765/mysql-drop-all-tables-ignoring-foreign-keys&quot;&gt;MySQL DROP all tables, ignoring foreign keys&lt;/a&gt;</code></pre>]]></content>
    
    
    <summary type="html">删除表不是特别常用，特别是对于存在外键关联的表，删除更得小心。但是在开发过程中，发现Schema设计的有问题而且要删除现有的数据库中所有的表来重新创建也是常有的事情；另外在测试的时候，也有需要重新创建数据库的所有表。当然很多自动化工具也可以做这样的事情。
</summary>
    
    
    
    <category term="MySQL" scheme="http://zh-liang-cn.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://zh-liang-cn.github.io/tags/MySQL/"/>
    
    <category term="Database" scheme="http://zh-liang-cn.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS与SSL(二)：X.509</title>
    <link href="http://zh-liang-cn.github.io/2013/09/13/https-ssl-x509/"/>
    <id>http://zh-liang-cn.github.io/2013/09/13/https-ssl-x509/</id>
    <published>2013-09-12T16:06:36.000Z</published>
    <updated>2021-10-30T16:18:49.726Z</updated>
    
    <content type="html"><![CDATA[<p>读完上一篇<a href="http://zhouliang.com/2013/08/26/https-ssl-rsa/">《HTTPS与SSL(一)：RSA》</a>，你应该大概了解了RSA加密在整个软件生态中起到的巨大作用。然而，现实生活中仅有加密还远远不够，假设你正在和小明打电话，即使电话传输中使用了万无一失的加密方式，<strong>你怎么保证正在和你对话的就是小明本人呢</strong>？你说，我听得出来小明的声音，但是声音可以造假；你说，我问小明几个只有我们两个知道答案的问题，呵呵，这种现实生活中也许可以，但是在互联网中世界中不可能（这种方式到是非常好地用在了一些网站的“找回密码”功能中）。</p><p>肿么办呢？X.509正是为此而生。</p><h2 id="使用RSA对消息签名"><a href="#使用RSA对消息签名" class="headerlink" title="使用RSA对消息签名"></a>使用RSA对消息签名</h2><p>先补充一点本来应该属于<a href="http://zhouliang.com/2013/08/26/https-ssl-rsa/">前一篇</a>的内容，写<a href="http://zhouliang.com/2013/08/26/https-ssl-rsa/">前一篇</a>的时候我忘记了，当我想起来的时候发现写在这里也许更加合适。<br>看了前面的RSA算法后就知道，其实公钥和私钥是可以<strong>相互</strong>（注意这个词）加密和解密的，即同样可以使用私钥对信息进行加密，然后只能用公钥才能解密。这个原理可以用于消息签名。<br>所谓消息签名指的是：</p><blockquote><p>假如甲想给乙传递一个署名的消息的话，那么她可以为她的消息计算一个散列值(Message digest)，然后用她的密钥(private key)加密这个散列值并将这个“署名”加在消息的后面。这个消息只有用她的公钥才能被解密。乙获得这个消息后可以用甲的公钥解密这个散列值，然后将这个数据与他自己为这个消息计算的散列值相比较。假如两者相符的话，那么他就可以知道发信人持有甲的密钥，以及这个消息在传播路径上没有被篡改过。</p></blockquote><p>好了，关于这点就到这里，先看看其他的内容，待会儿还有机会回头来看这里。</p><h2 id="解决关于信任的问题"><a href="#解决关于信任的问题" class="headerlink" title="解决关于信任的问题"></a>解决关于信任的问题</h2><p>其实解决问题的方法很简单，和我们国家实行的<a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81">身份证制度</a>一样，你可以凭借你的身份证来证明你是你自己。如果你弄丢了身份证，你说你是你自己没有用，你妈说你就是你也没有用，你必须靠身份证才能证明你是你自己。</p><p>这种方法的确是一种行之有效的方法。首先，我们设立一个公安部专门用于发放证书，和我们理解的充满了贪污腐败的生活不一样，我们完全信任这个公安局和他发放的证书。但是如果每个人都来找公安部，公安部就要忙疯了，因此公安部授权成立了省公安厅，依次往下推，一直到县级公安局。我们信任公安部，公安部信任省公安厅，省公安厅信任地级公安局，地级公安局信任县级公安局，因此我们也信任县级公安局。</p><p>反过来，如果小明拿着县级公安局发给他的身份证，因为我信任公安部，因此我就可以确认是小明本人，并且信任他。这正是<a href="http://baike.baidu.com/view/7615.htm">X.509协议</a>协议所设计的信任链模型，在X.509协议中，这一个授权链称为Cetrification Chain，公安部就是CA（Certification Authority），身份证就是证书（Certification），而我们的浏览器中内置了一些权威的根证书，浏览器会自动信任由这些权威机构颁发的其他证书。</p><p><a href="https://www.flickr.com/photos/zhlwish/14023127037/" title="Flickr 上 zhlwish 的 2013-09-12_2332"><img src="https://farm6.staticflickr.com/5582/14023127037_f7b383896f_o.png" width="484" height="295" alt="2013-09-12_2332"></a></p><p>上图是Gmail的证书，可以很清楚的看到这个证书链。Gmail网站的证书在最底层，处于最顶层的称为<strong>根证书</strong>，我们可以认为<strong>根证书</strong>就是公安部的“身份证”（实际上应该称为<a href="http://baike.baidu.com/view/359635.htm">组织机构代码证</a>）。每个国家都只有一个公安部，但是国际上不止一家顶级证书颁发机构（顶级CA）。我们所使用的浏览器默认内置了所有这些顶级CA的根证书，因此只要顶级CA颁发证书我们都可以信任。因此当我们访问了一个经过这些顶级CA认证的网站，我们可以在浏览器上看到绿色图标。</p><p>CA发放的证书中包括一个公钥（详见本文第3节），其对应的私钥也会同时发放给服务提供商，用于服务提供商和其客户的通信加密。如果服务提供商不小心将私钥弄泄露了，他可以向CA申请召回（Revoke）这个证书，并申请新的证书，CA维护了一个称为Certificate Revocation List的列表。这个证书被召回后，所有的客户可以通过CA查询到这个证书已经被召回，不再使用泄露了私钥的公钥进行加密通信。下图是Chrome浏览器的HTTPS/SSL选项，默认情况下Chrome会检查服务器的证书是否被召回。</p><p><a href="https://www.flickr.com/photos/zhlwish/14023055658/" title="Flickr 上 zhlwish 的 2013-09-04_0004"><img src="https://farm6.staticflickr.com/5039/14023055658_1baee607fa_o.png" width="529" height="114" alt="2013-09-04_0004"></a></p><p>这个过程和下面的这种情况比较类似：如果小明的身份证丢失了，他需要立即通知公安部废止这个身份证，然后重新办理新的身份证。（注：你能想象么，现实生活中的身份证居然是无法废止的，详见这个新闻<a href="http://npc.people.com.cn/n/2013/0821/c14576-22636564.html">《身份证漏洞帮了犯罪分子的忙》</a>，你基本可以认为设计身份证系统的“砖家”完全没有安全意识，不过，这已经见怪不怪了）</p><h2 id="X-509证书"><a href="#X-509证书" class="headerlink" title="X.509证书"></a>X.509证书</h2><p>X.509协议是国际电信组织（ITU）的一个标准，正是<strong>这个标准定义了我们上面所说的这一套流程</strong>，专业术语称为<strong>PKI</strong>（public key infrastructure）以及<strong>PMI</strong>（Privilege Management Infrastructure）。我们更加关心的是，这个标准定义了证书的格式。<br>我们先看一个例子，这个例子摘自<a href="http://en.wikipedia.org/wiki/X.509">维基百科</a>，是<a href="http://www.freesoft.org网站的证书/">www.freesoft.org网站的证书</a>, 重要的字段分别如下：</p><ul><li><em>Issuer</em> 字段显示该证书是由<a href="https://www.thawte.com">Thawte</a>发布的，<code>OU</code>、<code>CN</code>等缩略语和LDAP中的缩略语一样，<code>OU</code>表示<code>Organization Unit</code>，中文中最能传神的翻译应该是<code>单位</code>了，我尚不清楚这些缩略语是在哪个标准中定义；</li><li><em>Subject</em> 字段显示这个证书是颁发给谁的，其中<code>CN</code>的值应该和使用这个证书的网站的域名一致，<code>CN</code>表示<code>Common Name</code>；</li><li><em>Subject Public Key Info</em> 字段是公钥信息，<em>Public Key Algorithm</em> 显示这个公钥使用的RSA算法，<em>RSA Public Key</em> 字段中是RSA的公钥了；</li><li><em>Signature Algorithm</em> 字段是这个证书的签名，用于验证这个证书是不是真的是Issuer（在本例中是<a href="https://www.thawte.com">Thawte</a>）发布的，详见下一节。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">   Data:</span><br><span class="line">       Version: 1 (0x0)</span><br><span class="line">       Serial Number: 7829 (0x1e95)</span><br><span class="line">       Signature Algorithm: md5WithRSAEncryption</span><br><span class="line">       Issuer: C=ZA, ST=Western Cape, L=Cape Town, O=Thawte Consulting cc,</span><br><span class="line">               OU=Certification Services Division,</span><br><span class="line">               CN=Thawte Server CA/emailAddress=server-certs@thawte.com</span><br><span class="line">       Validity</span><br><span class="line">           Not Before: Jul  9 16:04:02 1998 GMT</span><br><span class="line">           Not After : Jul  9 16:04:02 1999 GMT</span><br><span class="line">       Subject: C=US, ST=Maryland, L=Pasadena, O=Brent Baccala,</span><br><span class="line">                OU=FreeSoft, CN=www.freesoft.org/emailAddress=baccala@freesoft.org</span><br><span class="line">       Subject Public Key Info:</span><br><span class="line">           Public Key Algorithm: rsaEncryption</span><br><span class="line">           RSA Public Key: (1024 bit)</span><br><span class="line">               Modulus (1024 bit):</span><br><span class="line">                   00:b4:31:98:0a:c4:bc:62:c1:88:aa:dc:b0:c8:bb:</span><br><span class="line">                   33:35:19:d5:0c:64:b9:3d:41:b2:96:fc:f3:31:e1:</span><br><span class="line">                   66:36:d0:8e:56:12:44:ba:75:eb:e8:1c:9c:5b:66:</span><br><span class="line">                   70:33:52:14:c9:ec:4f:91:51:70:39:de:53:85:17:</span><br><span class="line">                   16:94:6e:ee:f4:d5:6f:d5:ca:b3:47:5e:1b:0c:7b:</span><br><span class="line">                   c5:cc:2b:6b:c1:90:c3:16:31:0d:bf:7a:c7:47:77:</span><br><span class="line">                   8f:a0:21:c7:4c:d0:16:65:00:c1:0f:d7:b8:80:e3:</span><br><span class="line">                   d2:75:6b:c1:ea:9e:5c:5c:ea:7d:c1:a1:10:bc:b8:</span><br><span class="line">                   e8:35:1c:9e:27:52:7e:41:8f</span><br><span class="line">               Exponent: 65537 (0x10001)</span><br><span class="line">    Signature Algorithm: md5WithRSAEncryption</span><br><span class="line">       93:5f:8f:5f:c5:af:bf:0a:ab:a5:6d:fb:24:5f:b6:59:5d:9d:</span><br><span class="line">       92:2e:4a:1b:8b:ac:7d:99:17:5d:cd:19:f6:ad:ef:63:2f:92:</span><br><span class="line">       ab:2f:4b:cf:0a:13:90:ee:2c:0e:43:03:be:f6:ea:8e:9c:67:</span><br><span class="line">       d0:a2:40:03:f7:ef:6a:15:09:79:a9:46:ed:b7:16:1b:41:72:</span><br><span class="line">       0d:19:aa:ad:dd:9a:df:ab:97:50:65:f5:5e:85:a6:ef:19:d1:</span><br><span class="line">       5a:de:9d:ea:63:cd:cb:cc:6d:5d:01:85:b5:6d:c8:f3:d9:f7:</span><br><span class="line">       8f:0e:fc:ba:1f:34:e9:96:6e:6c:cf:f2:ef:9b:bf:de:b5:22:</span><br><span class="line">       68:9f</span><br></pre></td></tr></table></figure><h2 id="证书的消息签名"><a href="#证书的消息签名" class="headerlink" title="证书的消息签名"></a>证书的消息签名</h2><p>前一节提到证书的最后一部分是证书的签名，用于验证证书的真实性。这又是什么原理呢？<br>先谈这段消息签名的生成方法：</p><ul><li>Issuer（本例中的<a href="https://www.thawte.com">Thawte</a>）先计算证书前一部分内容的MD5值；</li><li>Issuer然后使用他自己的RSA私钥加密。</li></ul><p>在本文第一节《使用RSA对消息签名》中提到，用私钥加密的消息同样可以使用其对应的公钥进行解密，因为浏览器已经内置了一些权威的根证书（包括本例中的<a href="https://www.thawte.com">Thawte</a>），这个根证书中包括了其公钥，因此浏览器可以使用<a href="https://www.thawte.com">Thawte</a>的公钥对这段签名进行解密，然后验证解密后的内容是否和证书的前一段内容一致，如果一致，就说明了颁发该证书的服务商的确拥有<a href="https://www.thawte.com">Thawte</a>的私钥，从而证明了这个证书的真实性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后，因为本文为了理论能讲述得形象一些，不得不类比了一些现实生活，因此我是在愤怒写完这篇博文的，你应该能体会我的心情。《HTTPS与SSL》未完待续，敬请期待！</p>]]></content>
    
    
    <summary type="html">读完上一篇&lt;a href=&quot;http://zhouliang.com/2013/08/26/https-ssl-rsa/&quot;&gt;《HTTPS与SSL(一)：RSA》&lt;/a&gt;，你应该大概了解了RSA加密在整个软件生态中起到的巨大作用。然而，现实生活中仅有加密还远远不够，假设你正在和小明打电话，即使电话传输中使用了万无一失的加密方式，你怎么保证正在和你对话的就是小明本人呢？你说，我听得出来小明的声音，但是声音可以造假；你说，我问小明几个只有我们两个知道答案的问题，呵呵，这种现实生活中也许可以，但是在互联网中世界中不可能（这种方式到是非常好地用在了一些网站的找回密码功能中）。
肿么办呢？X.509正是为此而生。
</summary>
    
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/categories/Linux/"/>
    
    
    <category term="SSH" scheme="http://zh-liang-cn.github.io/tags/SSH/"/>
    
    <category term="HTTPS" scheme="http://zh-liang-cn.github.io/tags/HTTPS/"/>
    
    <category term="SSL" scheme="http://zh-liang-cn.github.io/tags/SSL/"/>
    
    <category term="Algorithm" scheme="http://zh-liang-cn.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS与SSL(一)：RSA</title>
    <link href="http://zh-liang-cn.github.io/2013/08/26/https-ssl-rsa/"/>
    <id>http://zh-liang-cn.github.io/2013/08/26/https-ssl-rsa/</id>
    <published>2013-08-25T17:06:36.000Z</published>
    <updated>2021-10-30T16:18:49.725Z</updated>
    
    <content type="html"><![CDATA[<p>工作中常遇到一些关于安全方面的名词，如SSL、HTTPS、证书、pem、keystore、PGP等，作为不是对安全不甚了解的程序员而言，深感压力巨大，于是趁周末得闲查阅了相关资料，做简要记录。</p><h2 id="非对称加密与RSA"><a href="#非对称加密与RSA" class="headerlink" title="非对称加密与RSA"></a>非对称加密与RSA</h2><p>一切的一切还得从 <strong>非对称加密</strong> 说起。在信息安全领域，加密方式分为对称加密与非对称加密。对称加密中，加密秘钥和解密秘钥完全相同，安全性不高。而非对称加密的加密秘钥和解密秘钥不同，具有更高的安全性，应用更加广泛.</p><p>在非对称加密中，加密秘钥称为 <strong>公钥</strong>(Public Key)，而解密秘钥称为 <strong>私钥</strong>(Private)，而且他们总是成双成对的。一般情况下，我们通过一些工具生成一对公钥和私钥后，将公钥发布给其他人，这样其他人就可以将消息使用公钥加密后发给给我，我接受到消息后，使用我的私钥将消息解密。</p><p><a href="https://www.flickr.com/photos/zhlwish/14023088500/" title="Flickr 上 zhlwish 的 rsa"><img src="https://farm3.staticflickr.com/2897/14023088500_da1890e07c_o.png" width="795" height="259" alt="rsa"></a></p><p>非对称加密有很多种，详见维基百科 <a href="http://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">公开秘钥加密</a>，使用最广泛的是<a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA算法</a>。<br>想想就觉得很神奇，这是怎么做到的呢。我大概了解了一下<a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA算法</a>，主要是基于数论中的<a href="https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">费马小定理</a>。虽然我暂时还不能理解为什么是这样，但是经过我的验证，的确很神奇，大概步骤如下：</p><ol><li>随意选两个大的质数<code>p</code>和<code>q</code>，<code>p</code>不等于<code>q</code>，计算<code>N = pq</code>；我选择了<code>p = 97</code>，<code>q = 73</code>，<code>n = p * q = 7081</code>；</li><li>根据<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">欧拉函数</a>，求得小于或者等于<code>N</code>的正整数中与<code>N</code>互质的数个数：<code>r = &amp;phi;(N) = &amp;phi;(p)&amp;phi;(q) = (p-1)(q-1)</code>；本例中<code>r = 96 * 72 = 6912</code>；</li><li>选择一个小于<code>r</code>并且与<code>r</code>互质的整数<code>e</code>，求<code>e</code>关于模<code>r</code>的<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0">模反元素</a><code>d</code>；我选择了质数<code>13</code>，肯定与<code>6912</code>互质，求得<code>d = 5317</code>；</li><li>将<code>(N, e)</code>作为公钥用于加密，将<code>(N, d)</code>作为私钥用于解密；即<code>(7081, 13)</code>是公钥，可以分发给其他人，而<code>(7081, 5317)</code>是私钥，需要保密；</li><li>如果传送的数字为<code>m</code>，加密公式为：<code>m ^ e % N</code>；假设需要传送数字<code>100</code>，<code>100 ^ 13 % 7081 = 1195</code>；</li><li>假如收到的数字为<code>n</code>，解密公式为：<code>n ^ d % N</code>；如果收到的数字为<code>1195</code>，则解密后得到：<code>1195 ^ 5317 % 7081 = 100</code>。</li></ol><p>总之，过程很奇妙，而且鉴于实现这个过程的算法和数论理论都是在几百年前发现的，让人不得惊叹人类的智慧和数字的奇妙！<a href="https://gist.github.com/zhlwish/6334261">这里</a>是我检验上面算法所使用的Ruby程序，有兴趣的话也实践一下吧。</p><p>在计算机中，字符串经过编码（如ASIIC、Unicode）后实际上是数字。也就是说如果要加密字符串，可以将字符串编码成数字，然后对数字进行加密。解密后，再将数字转换成字符串。</p><p>我们现在常用的RSA的秘钥的长度是1024位，不过据称这个长度的RSA已经有被破解的危险，因此提倡使用2048位长度的RSA，然而，Windows XP等早期的系统不支持2048位的RSA算法。</p><h2 id="SSH与RSA"><a href="#SSH与RSA" class="headerlink" title="SSH与RSA"></a>SSH与RSA</h2><p>我们在使用<a href="http://zh.wikipedia.org/wiki/Secure_Shell">SSH</a>连接到服务器时也会用到RSA。当然，SSH协议本身设计得具有很强大的扩展性，支持很多种加密算法，RSA只是其中的一种，不过也是应用最广泛的一种。下面是使用<a href="http://en.wikipedia.org/wiki/Ssh-keygen">ssh-keygen</a>工具生成公钥和私钥的过程：</p><pre><code>$ ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/Users/liang/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /Users/liang/.ssh/id_rsa.Your public key has been saved in /Users/liang/.ssh/id_rsa.pub.The key fingerprint is:19:03:9f:99:ef:65:cc:44:d9:f4:89:89:47:89:da:ff liang@liang-macproThe key&#39;s randomart image is:# 后面的输出省略……</code></pre><p>这个命令会生成两个文件：<code>/Users/liang/.ssh/id_rsa.pub</code>和<code>/Users/liang/.ssh/id_rsa</code>。前者是公钥，在建立SSH连接时会发送给服务器，服务器将数据使用此公钥加密后传送给客户端（本机）。后者是私钥，客户端（本机）使用此秘钥对服务器发送的数据进行解密，这个文件很重要，绝对不能外泄，因此最好是能对此文件进行加密，上面命令执行时中间有一个步骤会请你输入密码，这个密码就用于<a href="https://help.github.com/articles/working-with-ssh-key-passphrases">加密私钥</a>。</p><p>SSH除了使用用户名密码进行身份验证外，也可以使用公钥进行身份验证。客户端连接服务器时，将客户端的公钥传送给服务器，服务器收到请求后，首先在服务器用户根目录<code>~/.ssh/authorized_keys</code>寻找相应的公钥，如果两个秘钥一致，则验证通过。服务器会使用该公钥将数据加密进行传送。</p><p>而当客户端连接到服务器时，服务器也会将其公钥传送给客户端，可以在<code>~/.ssh/known_hosts</code>文件中找到，从而实现双向数据加密。</p><p>讲到这里，就不能不提到<a href="http://rcsg-gsir.imsb-dsgi.nrc-cnrc.gc.ca/documents/internet/node31.html">Password-less SSH</a>了，也就是常说的不用密码登录SSH，实现的步骤如下：</p><ol><li>在客户端使用<code>ssh-keygen -t rsa</code>生成公钥和秘钥文件，在输入密码的阶段直接输入回车</li><li>将<code>~/.ssh/id_rsa.pub</code>文件的内容添加到服务器上<code>~/.ssh/authorized_keys</code>后面并保存</li></ol><p>理解了原理后，深感这个过程太简单了。但是需要注意的是这样其实并不安全，因为私钥有暴露的危险，除非将<code>~/.ssh/id_rsa</code>文件的权限设为<code>600</code>，还可以用<a href="http://en.wikipedia.org/wiki/Ssh-agent">ssh-agent</a>来实现同样的效果。</p><p>到这里，作为一篇博文的篇幅算是差不多了，《HTTPS与SSL》未完待续，敬请期待！</p>]]></content>
    
    
    <summary type="html">工作中常遇到一些关于安全方面的名词，如SSL、HTTPS、证书、pem、keystore、PGP等，作为不是对安全不甚了解的程序员而言，深感压力巨大，于是趁周末得闲查阅了相关资料，做简要记录。
</summary>
    
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/categories/Linux/"/>
    
    
    <category term="SSH" scheme="http://zh-liang-cn.github.io/tags/SSH/"/>
    
    <category term="HTTPS" scheme="http://zh-liang-cn.github.io/tags/HTTPS/"/>
    
    <category term="SSL" scheme="http://zh-liang-cn.github.io/tags/SSL/"/>
    
    <category term="Algorithm" scheme="http://zh-liang-cn.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>波兰式、逆波兰式与表达式求值</title>
    <link href="http://zh-liang-cn.github.io/2013/08/18/polish_notation-reverse_polish_notation/"/>
    <id>http://zh-liang-cn.github.io/2013/08/18/polish_notation-reverse_polish_notation/</id>
    <published>2013-08-18T13:15:38.000Z</published>
    <updated>2021-10-30T16:18:49.735Z</updated>
    
    <content type="html"><![CDATA[<p>波兰式、逆波兰式是《数据结构》课程中讲解关于栈的时候提到的，栈是很简单的一种数据结构。但是这些理论的提出却是计算机早期发展领域的重大突破，值得仔细回味。</p><h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><p>我们在数学中学到的表达式被称为中缀表达式，操作符号在操作数中间，比如 <code>2 + 3 * (5 - 1)</code>。对人类而言，这种表达方式显而易见，求值也很直接，先算乘除再算加减，先算括号内再算括号外。<br>然而，这个表达式对于计算机而言却很费解。你可能会有疑问：这有什么难理解的嘛，在JavaScript、Python或者Ruby，甚至是<a href="http://stackoverflow.com/questions/2605032/using-eval-in-java">Java</a>里面都可以通过<code>eval(&quot;2 + 3 * (5 - 1)&quot;)</code>来计算这个表达式。当然，这里的计算机并不是指现而今强大的计算机和高级编程语言，而是指上个世纪中页还处于发展初期的计算机。</p><h2 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h2><p>早在1920年，波兰科学家<a href="http://en.wikipedia.org/wiki/Jan_%C5%81ukasiewicz">扬&middot;武卡谢维奇</a>就发明了一种<strong>不需要括号</strong>的表示法，可以用来表示一个计算表达式。即将操作符号写在操作数之前，也就是前缀表达式，即波兰式（Polish Notation, PN）。这种表达式直到1960年计算机出现后才发挥出其威力。</p><p>比如<code>2 + 3 * (5 - 1)</code>这个表达式的前缀表达式为<code>+ 2 * 3 - 5 1</code>来表示。<br>阅读这个表达式需要从左至右读入表达式，如果一个操作符后面跟着两个操作数时，则计算，然后将结果作为操作数替换这个操作符和两个操作数，重复此步骤，直至所有操作符处理完毕。从左往右依次读取，直到遇到<code>- 5 1</code>，做计算后，将表达式替换为<code>+ 2 * 3 4</code>，然后从左往右再次读取，直到遇到<code>* 3 4</code>，做计算后将表达式替换为<code>+ 2 12</code>，然后从左往右依次读取，读到<code>+ 2 12</code>，计算得到14，到此结束。<br>可以看到，这种计算过程也相当复杂，需要多次遍历表达式，而且需要识别_一个操作符后面跟着两个操作数_这种模式，相比而言，下文中的逆波兰式要更为直接和简单。</p><p>如果你熟悉各种编程语言的话，这很像Lisp语言中的表达式（<a href="http://clojure.org/getting_started">如下代码</a>）。需要注意的是，Lisp语言中的括号并不是数学意义上的的括号，Lisp中的函数是可以携带多个参数的，比如<code>(+ 1 2 3)</code>，因此需要使用括号来标明函数参数。</p><pre><code>Clojure 1.5.1user=&gt; (+ 2 (* 3 (- 5 1)))14</code></pre><h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><p>后缀表达式也称为<strong>逆波兰式</strong>（Reverse Polish Notation, RPN），更加广为人知一些，和前缀表达式刚好相反，是将操作符号放置于操作数之后，比如<code>2 + 3 * (5 - 1)</code>用逆波兰式来表示则是：<code>2 3 5 1 - * +</code>。</p><p>逆波兰式的计算也是从左往右依次读取，当读到操作符时，将之前的两个操作数做计算，然后替换这两个操作数和操作符，接着读取，重复此步骤。对于这个表达式，读到<code>5 1 -</code>，得到<code>4</code>，然后读取乘号，取出前面的<code>3</code>和上一步的计算结果<code>4</code>，并计算，到<code>12</code>，接着读取加号<code>+</code>，计算<code>2 12 +</code>得到<code>14</code>，计算结束。<br>上面这个步骤可以很容易的用栈来实现：</p><blockquote><p>从左往右依次读取表达式，如果是数字则将该数字压栈，如果是符号，则将之前的两个数字出栈，做计算后，将计算结果压栈，直到表达式读取结束。栈中剩下的一个数就是计算结果。</p></blockquote><p>逆波兰式看起来像波兰式反过来，比如<code>5 + 1</code>的波兰式是<code>+ 5 1</code>，逆波兰式为<code>5 1 +</code>或者<code>1 5 +</code>。也很明显，逆波兰式并不是简单的将波兰式反过来，因为，减法和除法中减数和被减数、除数与被除数是不能交换的，即<code>- 10 5</code>和<code>- 5 10</code>就完全不一样。</p><h2 id="中缀表达式到后缀表达式的转换"><a href="#中缀表达式到后缀表达式的转换" class="headerlink" title="中缀表达式到后缀表达式的转换"></a>中缀表达式到后缀表达式的转换</h2><p>因为通过后缀表达式来进行计算只需要一个栈即可，从硬件和软件上实现都是极为便利的，因此逆波兰式在计算机领域的应用更加广泛，因此将中缀表达式转换为逆波兰式非常重要。<br>依然仅仅使用栈就可以将中缀表达式转换成逆波兰式，转换过程如下：</p><blockquote><p>从左往右遍历中缀表达式中的每个数字和符号，弱是数字就输出，成为逆波兰式的一部分； 如果是右括号，或者是其他符号并且比当前栈顶符号的优先级低，则栈顶元素依次出栈并输出； 然后将当前符号进栈，重复以上操作直到结束。</p></blockquote><p>还是以<code>2 + 3 * (5 - 1)</code>为例：</p><ul><li>首先读入数字<code>2</code>，直接将其输出，输出为<code>2</code>，栈为空</li><li>接着读入加号<code>+</code>，由于栈为空，因此将其进栈，输出为<code>2</code>，栈为<code>+</code></li><li>接着读入数字<code>3</code>，直接将其输出，输出为<code>2 3</code>，栈为<code>+</code></li><li>接着读入乘号<code>*</code>，比栈顶元素优先级高，进栈，输出为<code>2 3</code>，栈为<code>+ *</code></li><li>读入左括号<code>(</code>，直接进栈，输出<code>2 3</code>，栈为<code>+ * (</code></li><li>读入数字<code>5</code>，直接将其输出，输出为<code>2 3 5</code>，栈为<code>+ * (</code></li><li>读入减号<code>-</code>，栈顶元素为左括号，进栈，输出为<code>2 3 5</code>，栈为<code>+ * ( -</code></li><li>读入数字<code>1</code>，直接将其输出，输出为<code>2 3 5 1</code>，栈为<code>+ * ( -</code></li><li>读入右括号，依次输出栈顶元素，直到左括号，括号不输出，输出<code>2 3 5 1 -</code>，栈为<code>+ *</code></li><li>已经无元素可读，依次输出栈顶元素，直到栈为空，输出<code>2 3 5 1 - * +</code>，栈为空</li></ul><p>这样可以仅仅使用栈，首先将中缀表达式转换为逆波兰式，然后用本文第3节中的方法对后缀表达式进行求值，整个过程使用栈来完成即可。</p><h2 id="表达式树与逆波兰式"><a href="#表达式树与逆波兰式" class="headerlink" title="表达式树与逆波兰式"></a>表达式树与逆波兰式</h2><p>还可以通过另外一种方法来将一个表达式转换成波兰式和逆波兰式，这种方法依赖与树，首先需要根据表达式构建成树，仍然以<code>2 + 3 * (5 - 1)</code>为例，下图是其表达式树。</p><p><a href="https://www.flickr.com/photos/zhlwish/14186573746/" title="Flickr 上 zhlwish 的 RPN-Tree-New-Page"><img src="https://farm3.staticflickr.com/2911/14186573746_896714d964_o.png" width="360" height="326" alt="RPN-Tree-New-Page"></a></p><p>我们发现这个树的后序遍历结果为<code>2 3 5 1 - * +</code>，刚好是其逆波兰式；而其先序遍历结果为<code>+ 2 * 3 - 5 1</code>刚好为其波兰式；中序遍历就不用说了，就是我们常见的中缀表达式。我们也可以通过这种特性来实现表达式的各种表示方法的转换。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波兰表示法</a></li><li><a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">波兰表示法</a></li><li><a href="http://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95">调度场算法</a></li><li><a href="http://www.cnblogs.com/stay-foolish/archive/2012/04/25/2470590.html">将表达式转换成逆波兰式</a></li></ul>]]></content>
    
    
    <summary type="html">波兰式、逆波兰式是《数据结构》课程中讲解关于栈的时候提到的，栈是很简单的一种数据结构。但是这些理论的提出却是计算机早期发展领域的重大突破，值得仔细回味。
</summary>
    
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/categories/Linux/"/>
    
    
    <category term="Algorithm" scheme="http://zh-liang-cn.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Java工作流引擎：jBPM、Activiti以及SWF</title>
    <link href="http://zh-liang-cn.github.io/2013/07/06/bpm-jbpm-activiti/"/>
    <id>http://zh-liang-cn.github.io/2013/07/06/bpm-jbpm-activiti/</id>
    <published>2013-07-06T03:19:25.000Z</published>
    <updated>2021-10-30T16:18:49.720Z</updated>
    
    <content type="html"><![CDATA[<p>这只是一篇非常粗浅的记录我对工作流引擎认识的文章。<br>知道工作流引擎是很久之前了，但是一直都没有机会尝试，一是没有业务上的需要，二是感觉工作流入门不容易。最近，项目中用到了一点工作流的东西，虽然我没有具体参与，但是了解一下还是好的。于是抽周末两天时间读了一些文章和jBPM以及Activiti的User Reference，本文做一下记录。SWF指的是Amazon Simple Workflow。</p><h2 id="工作流引擎是什么？"><a href="#工作流引擎是什么？" class="headerlink" title="工作流引擎是什么？"></a>工作流引擎是什么？</h2><p>“工作流引擎”这个名字听起来很吓人（“引擎”这两个字眼总是能吓人的），我之前就是被吓着了的程序员中的一个。百度词条<a href="http://baike.baidu.com/view/1636259.htm">工作流引擎</a>也很难懂。<br>我们经常做一些程序，比如用户A填一张表，提交后，会给另一个用户B（通常是另一类较色）审核，他们觉得没有问题就确定，最后给原来A用户发送一封邮件。在实现这一类系统时我们会设计一张任务表，这个表中有一列成为Status(状态)：用户提交后状态是0，审核通过后状态是1，审核没通过状态是2。但是这样设计会有一些扩展性的问题，比如：</p><ul><li>我需要知道某表单的历史信息：什么时候由谁提交、什么时候被审核通过、被谁审核通过等</li><li>我需要扩展或者改动流程：A用户提交表单后，B用户希望能收到邮件提醒等</li><li>我需要定时执行一些任务：为A用户提交表单设置截止时间，提前截止时间一天发送邮件通知</li></ul><blockquote><p>这些需求用土鳖的方式是都可以实现，我以前在学校工作的时候，买设备走学校的采购流程系统，我就亲眼看到一个工作人员打开SQL Server去数据库中查询这个订单是什么时候下的。</p></blockquote><p>当然，这样的系统做得多了，就会对这些进行归纳抽象，比如:</p><ul><li>将任务状态表和历史记录表抽象出来成为 <strong>TaskService</strong> 和 <strong>HistoryService</strong> 模块</li><li>将定时任务以及抽象成 <strong>BusinessCalendar</strong> 模块</li><li>将用户管理的部分抽取出来成为 <strong>Identity</strong> 模块</li><li>将发送邮件抽象成 <strong>EmailTask</strong> 模块，使用的时候只需要配置一下收件人和内容即可</li><li>将需要调用Java类处理业务逻辑功能抽象成 <strong>Action</strong>，使用时配置一下具体调用哪一个Java类</li><li>最后做一个流程管理的通用界面，能实时监控流程的执行情况</li></ul><p>这些也都是jPBM以及Activiti等工作流引擎的核心模块。</p><h2 id="工作流引擎的基本概念"><a href="#工作流引擎的基本概念" class="headerlink" title="工作流引擎的基本概念"></a>工作流引擎的基本概念</h2><p>上一节所述A和B参与的工作流的例子，很好的描述了一个A和B的工作流程，我们用一种语言来将这种模式描述出来，jBPM5之前版本用的是jPDL，现在大家都用<a href="http://zh.wikipedia.org/wiki/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%BB%BA%E6%A8%A1%E6%A0%87%E8%AE%B0%E6%B3%95">BMPN</a>，两者大同小异，都是用XML来描述流程，也都有可视化设计器支持，不过BMPN是行业标准。<br>编写好流程定义（Process Defintion）文件以及相关的Java类后，就可以部署到引擎中，每一次执行称为一个流程实例（Process Instance）。</p><p>工作流有版本的概念，jBPM和Activiti上传一个新的版本后，版本号会增加1，旧版本还没执行完的流程实例还会继续执行。SWF的版本是个字符串，随意指定好了，这样也很好，字符串名称更明确。<br>前面提到工作流抽象出来的各个模块，他们之间也是需要相互交互的，比如 <strong>EmailTask</strong> 就需要调用 <strong>Identity</strong> 模块来查找用户的Email信息、用户的姓名等。因此需要一个流程上下文（Process Context）来协调。</p><p>最后，流程的各个Task（或者称为Activity）之间可能要共享一点信息，jBPM和Actviti都有流程上下文实例（Process Context Instance）的概念，很像一个Hash，存放key-value信息，当然比Hash更强一点的是，流程上下文实例支持作用域的概念。</p><h2 id="工作流引擎的组成部分"><a href="#工作流引擎的组成部分" class="headerlink" title="工作流引擎的组成部分"></a>工作流引擎的组成部分</h2><h3 id="流程定义"><a href="#流程定义" class="headerlink" title="流程定义"></a>流程定义</h3><p>所谓流程定义即使用XML编写的用于描述流程的文件，你需要掌握一些BMPN的知识。很多工作流引擎都带有可视化流程设计器，但是需要理解的是，背后其实还是XML，下面是一个定义了4个结点的示例。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;myProcess&quot;</span> <span class="attr">name</span>=<span class="string">&quot;My process&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startevent</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Start&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">startevent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endevent</span> <span class="attr">id</span>=<span class="string">&quot;end&quot;</span> <span class="attr">name</span>=<span class="string">&quot;End&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">endevent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scripttask</span> <span class="attr">id</span>=<span class="string">&quot;script&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Script Task&quot;</span> <span class="attr">scriptFormat</span>=<span class="string">&quot;javascript&quot;</span> <span class="attr">activiti:autoStoreVariables</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">execution.setVariable(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Hello&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scripttask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servicetask</span> <span class="attr">id</span>=<span class="string">&quot;service&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Service Task&quot;</span> <span class="attr">activiti:class</span>=<span class="string">&quot;com.zhlwish.activity.demo01.HelloAction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">servicetask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceflow</span> <span class="attr">id</span>=<span class="string">&quot;flow1&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;start&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;script&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceflow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceflow</span> <span class="attr">id</span>=<span class="string">&quot;flow2&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;script&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;service&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceflow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceflow</span> <span class="attr">id</span>=<span class="string">&quot;flow3&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;service&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;end&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceflow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">&#123;% endhighlight%&#125;</span><br><span class="line"></span><br><span class="line">定以好流程后，就可以发布到工作流引擎，工作流引擎负责解析这个XML，并且存到数据库中。我们通过API来启动一个流程。</span><br><span class="line"></span><br><span class="line">### API</span><br><span class="line"></span><br><span class="line">对于苦逼的程序员来讲，API就是一切，不过经过抽象后的API也不复杂，基本上还是前面前面一节所述的概念的抽象。下面是Activiti工作流引擎部署流程定义文件，并启动一个流程的示例代码：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">repositoryService.createDeployment().addClasspathResource(&quot;Demo1.bpmn&quot;).deploy();</span><br><span class="line">RuntimeService runtimeService = processEngine.getRuntimeService();</span><br><span class="line">ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(&quot;myProcess&quot;);</span><br><span class="line">&#123;% endhighlight%&#125;</span><br><span class="line"></span><br><span class="line">流程启动后，可以通过API来对流程进行控制，如触发一个消息等待任务（receiveTask），甚至是将任务分配给某个用户，获取某个用户的所有任务等。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">List<span class="tag">&lt;<span class="name">Task</span>&gt;</span> tasks = taskService.createTaskQuery()</span><br><span class="line">     .taskAssignee(&quot;admin&quot;)</span><br><span class="line">     .orderByDueDate().asc()</span><br><span class="line">     .list();</span><br></pre></td></tr></table></figure><p>这段代码是查询<code>admin</code>用户的所有任务，按照截止时间升序排序，也就是最紧急的放在最前面。</p><h2 id="嵌入式部署与独立"><a href="#嵌入式部署与独立" class="headerlink" title="嵌入式部署与独立"></a>嵌入式部署与独立</h2><p>嵌入式部署即将流程引擎嵌入部署于Web应用中，这是最容易也是最简单的方式，通过上面的API就可以实现。<br>独立部署即流程引擎被独立运行，Web应用通过Rest API或者其他方式调用流程引擎的接口。Activiti引擎实现了一套Rest API，SWF也实现了完整的API结构，包括各个语言的版本。</p><p>独立部署的好处就是，引擎独立运行，和外部系统很好的解耦了，外部系统的故障不会导致工作流引擎的崩溃。</p><h2 id="SWF"><a href="#SWF" class="headerlink" title="SWF"></a>SWF</h2><p>SWF与其说是工作流引擎，不如说是分布式计算调度框架，SWF中只包括Task和History两部分，甚至是每个Task之间如果要传递一些数据的话，都只能通过第三方存储（比如Message Queue或者Redis），不过这也给了编程更大的灵活性，问题是这种灵活性是不是非常需要。</p><p>一个SWF由Worker和Decider组成，Worker执行实际的任务，而Decider进行流程控制，两者严格上来讲没有区别，只是所执行的任务不同罢了。每个Worker和Decider会定期的去SWF的一个Task List取下一个任务。可以看出来这更像是一个“多线程”的结构，而SWF官方网站的Use Case是<a href="http://aws.amazon.com/swf/testimonials/swfnasa/">NASA的火星探索计划</a>中需要处理图片的系统，这其实也是一个更多侧重于计算的系统，流程反而非常简单。</p><p>另外，SWF（Simple Workflow）的一个Workflow不能太复杂，因为所有的流程控制都集中于Decider，如果太复杂的话Decider将无比庞大，给维护和扩展带来一定的困扰。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.kafeitu.me/activiti/2012/03/22/workflow-activiti-action.html">工作流引擎Activiti使用总结</a></li><li><a href="http://www.infoq.com/cn/articles/rh-jbpm5-activiti5</task>">纵观jBPM：从jBPM3到jBPM5以及Activiti5</a></li><li><a href="http://www.iteye.com/topic/333718">jbpm3与jbpm4实现对比</a></li><li><a href="http://blog.csdn.net/james999/article/details/1769592">揭秘jbpm流程引擎内核设计思想及构架</a></li><li><a href="http://www.activiti.org/userguide">Activiti UserGuide</a></li><li><a href="http://activiti.org/javadocs/">Activit JavaDoc</a></li><li><a href="http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-using-swf-api.html">Using the Amazon SWF API</a></li></ul>]]></content>
    
    
    <summary type="html">这只是一篇非常粗浅的记录我对工作流引擎认识的文章。知道工作流引擎是很久之前了，但是一直都没有机会尝试，一是没有业务上的需要，二是感觉工作流入门不容易。最近，项目中用到了一点工作流的东西，虽然我没有具体参与，但是了解一下还是好的。于是抽周末两天时间读了一些文章和jBPM以及Activiti的User Reference，本文做一下记录。SWF指的是Amazon Simple Workflow。
</summary>
    
    
    
    <category term="Java" scheme="http://zh-liang-cn.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>几个有意思的Ruby全局变量</title>
    <link href="http://zh-liang-cn.github.io/2013/01/15/ruby-global-variables-you-should-known/"/>
    <id>http://zh-liang-cn.github.io/2013/01/15/ruby-global-variables-you-should-known/</id>
    <published>2013-01-14T16:39:37.000Z</published>
    <updated>2021-10-30T16:18:49.738Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做Ruby on Rails往JRuby上的迁移工作，积累了一些关于平常写代码时不太容易注意的环境变量、命令行参数和全局变量，了解这些知识对于进一步学习Ruby有很大的帮助，也有助于阅读一些开源框架如<a href="http://rubyonrails.org/">Rails</a>、<a href="https://github.com/rspec">Rspec</a>的代码。本文是这个小系列的第三篇。其他两篇分别是<a href="http://zhouliang.pro/2013/01/10/ruby-environment-variables-you-should-known/">几个有意思的Ruby环境变量</a>和<a href="http://zhouliang.pro/2013/01/07/ruby-command-line-params-you-should-know/">几个有意思的Ruby命令行参数</a> 。</p><p>Ruby中的全局变量指以 <code>$</code> 开头的变量，<a href="http://blog.chinaunix.net/uid-26244834-id-2954687.html">Ruby内置的全局变量有55个（1.9版本）</a>，可以使用 <code>Kernel#global_variables()</code>方法查看所有的全局变量。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global_variables.sort</span><br><span class="line"><span class="comment"># =&gt; [:$!, :$&quot;, :$$, :$&amp;amp;, :$&#x27;, :$*, :$+, :$,, :$-0, :$-F, :$-I, :$-K, :$-W, :$-a, :$-d, :$-i, :$-l, :$-p, :$-v, :$-w, :$., :$/, :$0, :$1, :$2, :$3, :$4, :$5, :$6, :$7, :$8, :$9, :$:, :$;, :$&lt; , :$=, :$&gt;, :$?, :$@, :$DEBUG, :$FILENAME, :$KCODE, :$LOADED_FEATURES, :$LOAD_PATH, :$PROGRAM_NAME, :$SAFE, :$VERBOSE, :$\, :$_, :$`, :$binding, :$stderr, :$stdin, :$stdout, :$~]</span></span><br></pre></td></tr></table></figure><p>里面的大部分都比较少用到，下面是我用到的几个：</p><h2 id="stdin-stdout-stderr"><a href="#stdin-stdout-stderr" class="headerlink" title="$stdin, $stdout, $stderr"></a>$stdin, $stdout, $stderr</h2><p>分别代表标准输入、标准输出和错误输出，其变量类型为<a href="http://ruby-doc.org/core-1.9.3/IO.html">IO</a>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stdin</span>.<span class="keyword">class</span></span><br><span class="line"><span class="comment"># =&gt; IO</span></span><br></pre></td></tr></table></figure><p>需要在控制台打印日志时，可以直接将日志输出到标准输出流（大部分时候指控制台）。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log = Logger.new(<span class="variable">$stdout</span>)</span><br></pre></td></tr></table></figure><h2 id="0-PROGRAM-NAME"><a href="#0-PROGRAM-NAME" class="headerlink" title="$0, $PROGRAM_NAME"></a>$0, $PROGRAM_NAME</h2><p>都指代程序名称，下面是 <code>global.rb</code>文件的代码内容：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env ruby</span></span><br><span class="line">puts <span class="variable">$0</span></span><br><span class="line">puts <span class="variable">$PROGRAM</span>_NAME</span><br></pre></td></tr></table></figure><p>在控制台执行输出结果如下：</p><pre><code>$ ruby global.rbglobal.rbglobal.rb</code></pre><p>用处最广的地方可能是判断当前脚本是直接被执行还是被<code>require</code>，详见<a href="http://stackoverflow.com/questions/4687680/what-does-if-file-0-mean-in-ruby">what-does-if-file-0-mean-in-ruby</a>，<a href="http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-__FILE__">FILE</a>是一个Object对象的一个方法，返回当前源代码文件的名称，方法名称比较奇怪，不过奇怪的方法名称在Ruby中已经见怪不怪了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">__FILE__</span> == <span class="variable">$0</span></span><br><span class="line">    puts <span class="string">&#x27;do something&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="n-和"><a href="#n-和" class="headerlink" title="$n 和 $~"></a>$n 和 $~</h2><p><code>$n</code>在这里指代<code>$1</code>, <code>$2</code>, <code>$3</code>, …, <code>$9</code>，这个变量是和模式匹配运算符 <code>=~</code> 一起使用的，指代匹配到的字符串，比如</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1986-11-25&#x27;</span> =~ <span class="regexp">/(\d+)-(\d+)-(\d+)/</span></span><br><span class="line"><span class="comment"># =&gt; 0</span></span><br><span class="line">puts <span class="variable">$1</span></span><br><span class="line"><span class="comment"># =&gt; 1986</span></span><br><span class="line">puts <span class="variable">$2</span></span><br><span class="line"><span class="comment"># =&gt; 11</span></span><br><span class="line">puts <span class="variable">$3</span></span><br><span class="line"><span class="comment"># =&gt; 25</span></span><br></pre></td></tr></table></figure><p>当然，大部分时候我们并不清楚会返回多少个匹配项，<code>$~</code>来拯救了，这个全局变量返回<a href="http://www.ruby-doc.org/core-1.9.3/MatchData.html">MatchData</a>对象，包括了所有的匹配。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="variable">$~</span></span><br><span class="line"><span class="comment"># =&gt; # matchdata &quot;1986-11-25&quot; 1:&quot;1986&quot; 2:&quot;11&quot; 3:&quot;25&quot; ;</span></span><br><span class="line">puts <span class="variable">$~</span>[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># =&gt; 1986</span></span><br></pre></td></tr></table></figure><p>最后，<code>$&amp;amp;</code>表示最近一次进行匹配的整个字符串，在上例中为<code>1986-11-25</code>。$<code>和</code>$’`也和匹配相关，分别表示当前匹配之前的字符串(pre-match)和当前匹配之后的字符串(post-match)，具体可以参考<a href="http://www.ruby-doc.org/core-1.9.3/MatchData.html#method-i-post_match">MatchData#post_match</a>，实在是比较少用到。</p><h2 id="LOAD-PATH-和"><a href="#LOAD-PATH-和" class="headerlink" title="$LOAD_PATH 和 $:"></a>$LOAD_PATH 和 $:</h2><p>我在<a href="http://zhouliang.pro/2013/01/10/ruby-environment-variables-you-should-known/">《几个有意思的Ruby环境变量》</a>中示例<code>RUBYLIB</code>和<code>RUBYOPT</code>环境变量的时候提到过这两个变量，两个都是数组，数组元素为Ruby的代码加载路径。<br>除了通过修改环境变量以外修改Ruby代码加载路径外，还可以通过修改这个全局变量来到达相同的效果。也就是说 <code>env RUBYLIB=/tmp/lib1</code> 和 <code>$LOAD_PATH &lt;&lt; &#39;/tmp/lib1&#39;</code>起到的作用一样，各有千秋。</p><h2 id=""><a href="#" class="headerlink" title="$$"></a>$$</h2><p>我们有个网站，后台挂了多个Rails进程，所有Rails的进程打印到同一个文件(production.log)中，我们希望在日志里输出一些信息的时候带上进程的id用于了解每个进程的状态，这个变量就用的上了，<code>$$</code>代表进程的id号。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>下面只是简单列举其他的几个全局变量，我从未在写代码的过程中使用过这些，因此只是简单罗列。</p><ul><li><code>$!</code>, 最近一次的错误信息 </li><li><code>$@</code>, 错误产生的位置 </li><li><code>$_</code>, gets最近读的字符串 </li><li><code>$.</code>, 解释器最近读的行数(line number) </li><li><code>$=</code>, 是否区别大小写的标志 </li><li><code>$/</code>, 输入记录分隔符 </li><li><code>$\</code>, 输出记录分隔符 </li><li><code>$*</code>, 命令行参数 </li><li><code>$?</code>, 最近一次执行的子进程退出状态</li></ul>]]></content>
    
    
    <summary type="html">最近在做Ruby on Rails往JRuby上的迁移工作，积累了一些关于平常写代码时不太容易注意的环境变量、命令行参数和全局变量，了解这些知识对于进一步学习Ruby有很大的帮助，也有助于阅读一些开源框架如&lt;a href=&quot;http://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt;、&lt;a href=&quot;https://github.com/rspec&quot;&gt;Rspec&lt;/a&gt;的代码。本文是这个小系列的第三篇。其他两篇分别是&lt;a href=&quot;http://www.zhlwish.com/2013/01/10/ruby-environment-variables-you-should-known/&quot;&gt;几个有意思的Ruby环境变量&lt;/a&gt;和&lt;a href=&quot;http://www.zhlwish.com/2013/01/07/ruby-command-line-params-you-should-know/&quot;&gt;几个有意思的Ruby命令行参数&lt;/a&gt; 。
</summary>
    
    
    
    <category term="Ruby" scheme="http://zh-liang-cn.github.io/categories/Ruby/"/>
    
    
    <category term="ruby" scheme="http://zh-liang-cn.github.io/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>几个有意思的Ruby环境变量</title>
    <link href="http://zh-liang-cn.github.io/2013/01/10/ruby-environment-variables-you-should-known/"/>
    <id>http://zh-liang-cn.github.io/2013/01/10/ruby-environment-variables-you-should-known/</id>
    <published>2013-01-10T03:24:03.000Z</published>
    <updated>2021-10-30T16:18:49.738Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做Ruby on Rails往JRuby上的迁移工作，积累了一些关于平常写代码时不太容易注意的环境变量、命令行参数和全局变量，了解这些知识对于进一步学习Ruby有很大的帮助，也有助于阅读一些开源框架如<a href="http://rubyonrails.org/">Rails</a>、<a href="https://github.com/rspec">Rspec</a>的代码。本文是这个小系列的第二篇。</p><h2 id="RUBYLIB"><a href="#RUBYLIB" class="headerlink" title="RUBYLIB"></a>RUBYLIB</h2><p>这个环境变量告诉Ruby到哪儿去加载代码，在<a href="http://blog.aizatto.com/2007/05/30/what-version-of-ruby-am-i-using/">几个有意思的Ruby命令行参数</a>中提到过，和 <code>-Idirectory</code> 是一样的，在Ruby程序中可以通过 <code>$LOAD_PATH</code> 或者是 <code>$:</code> 这两个全局变量得到，当然也可以在Ruby程序中修改这两个变量来实现动态切换库文件的版本。JRuby通过 <code>jruby --1.9</code>或者<code>jruby --1.8</code>来实现1.9和1.8版本的切换就是通过这种方式完成的（只是感觉，没经过验证）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env RUBYLIB=/tmp/lib1:/tmp/lib2 ruby -e &quot;puts $LOAD_PATH&quot;</span><br><span class="line">ruby -I/tmp/lib1:/tmp/lib2 -e &quot;puts $:&quot;</span><br></pre></td></tr></table></figure><h2 id="RUBYOPT"><a href="#RUBYOPT" class="headerlink" title="RUBYOPT"></a>RUBYOPT</h2><p>这个环境变量告诉Ruby每次执行的时候都要自动加上那些参数，还是上面的例子，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export RUBYOPT=&quot;-I/tmp/lib1:/tmp/lib2 -w&quot;</span><br><span class="line">ruby -e &quot;puts $LOAD_PATH&quot;</span><br><span class="line">ruby -e &quot;puts $:&quot;</span><br></pre></td></tr></table></figure><p>反正，条条大路通罗马。</p><p>JRuby默认支持的Ruby版本是是1.8.7，为了不用每次执行<code>jruby</code>命令时都指定版本，我用了RUBYOPT，挺好！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jruby -e &quot;puts RUBY_VERSION&quot;</span><br><span class="line"># 1.8.7</span><br><span class="line">export RUBYOPT=&quot;--1.9&quot;</span><br><span class="line">jruby -e &quot;puts RUBY_VERSION&quot;</span><br><span class="line"># 1.9.2</span><br></pre></td></tr></table></figure><h2 id="RUBYPATH"><a href="#RUBYPATH" class="headerlink" title="RUBYPATH"></a>RUBYPATH</h2><p>这个变量我目前没有发现有什么用，<code>man ruby</code>中提到是指定 <code>-S gem</code>这样的参数时，Ruby寻找gem命令的路径，默认情况下Ruby也会查找PATH路径，但是前者比后者高。</p><h2 id="GEM-HOME"><a href="#GEM-HOME" class="headerlink" title="GEM_HOME"></a>GEM_HOME</h2><p>这个环境变量和rubygems相关，由于rubygems已经成为Ruby 1.9的一部分，因为也写在这里。GEM_HOME是通过 <code>gem install</code> 命令安装gem时的安装路径，这个路径下一般有5个文件夹</p><pre><code>bin               # 可执行脚本cache             # 缓存doc               # 文档gems              # gem的代码specifications    # gem的说明文件</code></pre><h2 id="GEM-PATH"><a href="#GEM-PATH" class="headerlink" title="GEM_PATH"></a>GEM_PATH</h2><p>GEM&#95;HOME是安装路径，而GEM&#95;PATH只是gem的查找路径，像<a href="http://ruby-china.org/wiki/rvm-guide">rvm</a>中有 <code>gemset</code> 的概念，也就意味着其实有多个GEM_PATH，<a href="https://gist.github.com/668037">Illustrates GEM&#95;HOME vs GEM&#95;PATH</a>这个gist比较详细的解释了GEM&#95;HOME和GEM&#95;PATH的不同，抄录在这里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export GEM_HOME=a</span><br><span class="line">export GEM_PATH=a</span><br><span class="line">gem install rack</span><br><span class="line">gem list                    # shows rack</span><br><span class="line">export GEM_HOME=b</span><br><span class="line">export GEM_PATH=b</span><br><span class="line">gem install rake</span><br><span class="line">gem list                    # shows rake (not rack)</span><br><span class="line">export GEM_PATH=a:b</span><br><span class="line">gem list                    # shows rake and rack</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><a href="http://ruby-china.org/wiki/rvm-guide">rvm</a> 是一个非常好的工具，开始我并不是很明白他是怎么实现的，后来了解到这些环境变量后，终于明白了。不信的话，你可以看看这个文件：<code>~/.rvm/bin</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.aizatto.com/2007/05/30/what-version-of-ruby-am-i-using/">What Version of Ruby Am I Using?</a></li><li><a href="http://ruby-china.org/wiki/rvm-guide">RVM 实用指南</a></li></ul>]]></content>
    
    
    <summary type="html">最近在做Ruby on Rails往JRuby上的迁移工作，积累了一些关于平常写代码时不太容易注意的环境变量、命令行参数和全局变量，了解这些知识对于进一步学习Ruby有很大的帮助，也有助于阅读一些开源框架如&lt;a href=&quot;http://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt;、&lt;a href=&quot;https://github.com/rspec&quot;&gt;Rspec&lt;/a&gt;的代码。本文是这个小系列的第二篇。 </summary>
    
    
    
    <category term="Ruby" scheme="http://zh-liang-cn.github.io/categories/Ruby/"/>
    
    
    <category term="ruby" scheme="http://zh-liang-cn.github.io/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>几个有意思的Ruby命令行参数 </title>
    <link href="http://zh-liang-cn.github.io/2013/01/07/ruby-command-line-params-you-should-know/"/>
    <id>http://zh-liang-cn.github.io/2013/01/07/ruby-command-line-params-you-should-know/</id>
    <published>2013-01-07T15:37:17.000Z</published>
    <updated>2021-10-30T16:18:49.737Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做Ruby on Rails往JRuby上的迁移工作，积累了一些关于平常写代码时不太容易注意的环境变量、命令行参数和全局变量，了解这些知识对于进一步学习Ruby有很大的帮助，也有助于阅读一些开源框架如<a href="https://github.com/rails/rails">Rails</a>、<a href="https://github.com/rspec/rspec-core">Rspec</a>的代码。本文算是这个小系列的第一篇。</p><h2 id="h"><a href="#h" class="headerlink" title="-h"></a>-h</h2><p>显示帮助，本文的大部分内容都是来自于这里，虽然写了将近一年时间的Ruby代码，但是却很少仔细阅读 <code>ruby -h</code> 的信息，更为详细的信息可以查看 <code>man ruby</code>。特别列出来，做个提醒。</p><h2 id="e-‘script’"><a href="#e-‘script’" class="headerlink" title="-e ‘script’"></a>-e ‘script’</h2><p>直接执行一段Ruby脚本，比如:</p><pre><code>$ ruby -e &#39;puts &quot;hello&quot;&#39;hello</code></pre><p>为了比较不同的Ruby实现和版本的性能，可以会执行一些简单的的脚本来进行对比（测试数据仅共演示用，更好的性能对比使用<a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/benchmark/rdoc/Benchmark.html">Benchmark</a>或者<a href="https://github.com/rdp/ruby-prof">ruby-prof</a>）：</p><pre><code>$ time ruby -e &#39;(0..100000000).reduce(:+)&#39;7.81s user 0.01s system 99% cpu 7.822 total$ time jruby -e &#39;(0..100000000).reduce(:+)&#39;5.18s user 0.24s system 108% cpu 4.989 total</code></pre><h2 id="r-‘lib’"><a href="#r-‘lib’" class="headerlink" title="-r ‘lib’"></a>-r ‘lib’</h2><p>强制让Ruby使用require去加载不包含在<a href="http://ruby-doc.org/core-1.9.3/">核心库</a>中的其他库，如<a href="http://ruby-doc.org/stdlib-1.9.3/">标准库</a>中的<a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/date/rdoc/Date.html">date</a>。</p><p>比如下面的命令会提示报错，因为Date在标注库，Ruby启动时不会默认加载。</p><pre><code>$ ruby -e &quot;puts Date.today&quot;-e:1:in &#39;main&#39; uninitialized constant Date (NameError)</code></pre><p>加上<code>-r</code>参数就不会报错了，相当于执行了<code>require &quot;date&quot;&quot;</code>.</p><pre><code>$ ruby -r date -e &quot;puts Date.today&quot;</code></pre><h2 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h2><p>让Ruby进行语法检查，确保没有括号不匹配，<code>do &amp;hellip; end</code>不匹配的等语法错误。比如：</p><pre><code>$ ruby -ce &#39;(1..2).each &#123; |i| puts i &#39;-e:1: syntax error, unexpected $end, expecting &#39;&#125;&#39;</code></pre><p>不过如果你的程序有自动测试的话，一般不需要这一步的。以防万一，万一有偷懒没写自动测试的情况下，可以为你守住最后一条防线。</p><h2 id="Idirectory"><a href="#Idirectory" class="headerlink" title="-Idirectory"></a>-Idirectory</h2><p>告诉Ruby到哪儿去加载代码。相当于在Ruby代码中执行<code>$LOAD_PATH &lt; &lt; directory</code>。我们使用的JRuby是经过自己修改过的，而且我司有自己的Package管理系统，rubygems和rake的代码分开放在独立的包中的，因此这个参数就起到了很大的作用。</p><p>另外，使用<code>RUBYLIB</code>这个环境变量也可以起到同样的效果</p><pre><code>$ env RUBY_LIB=&quot;directory&quot; ruby -e &quot;puts &#39;hello&#39;&quot;</code></pre><h2 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h2><p>显示Ruby的debug信息，相当于设置了全局变量$DEBUG为true，其实没什么用，只是比较好玩 :)</p><h2 id="S"><a href="#S" class="headerlink" title="-S"></a>-S</h2><p>这个参数如果不是这次从Ruby往JRuby迁移，我也不会觉得有什么用。Ruby有一套自己的命令，如果rake、gem、irb等等，Ruby自己有一个<code>RUBYPATH</code>的变量，<code>ruby -S rake -T</code>表示执行<code>RUBYPATH</code>下的rake命令。平常，我们并不需要了解这些，但是在JRuby中，我们就要这样了：</p><pre><code>jruby -S gem list</code></pre><p>如果你的机器安装了多个Ruby版本（不是用rvm），那么这个参数肯定有用的。</p>]]></content>
    
    
    <summary type="html">最近在做Ruby on Rails往JRuby上的迁移工作，积累了一些关于平常写代码时不太容易注意的环境变量、命令行参数和全局变量，了解这些知识对于进一步学习Ruby有很大的帮助，也有助于阅读一些开源框架如&lt;a href=&quot;https://github.com/rails/rails&quot;&gt;Rails&lt;/a&gt;、&lt;a href=&quot;https://github.com/rspec/rspec-core&quot;&gt;Rspec&lt;/a&gt;的代码。本文算是这个小系列的第一篇。 </summary>
    
    
    
    <category term="Ruby" scheme="http://zh-liang-cn.github.io/categories/Ruby/"/>
    
    
    <category term="ruby" scheme="http://zh-liang-cn.github.io/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>VIM字符大小写转换</title>
    <link href="http://zh-liang-cn.github.io/2012/09/27/vim-upcase-downcase/"/>
    <id>http://zh-liang-cn.github.io/2012/09/27/vim-upcase-downcase/</id>
    <published>2012-09-27T03:57:59.000Z</published>
    <updated>2021-10-30T16:18:49.742Z</updated>
    
    <content type="html"><![CDATA[<p>VIM提供了字符大小写转换的快捷键，在coding的时候会感觉很贴心，当然，前提是记住他们。</p><h2 id="转换一个字符"><a href="#转换一个字符" class="headerlink" title="转换一个字符"></a>转换一个字符</h2><p>大小写转换(大写转换成小写，小写转换成大写)快捷键<code>~</code>。</p><ul><li>转换1个字符，光标移动到要转换的字符上，按<code>~</code></li><li>转换多个字符，将光标移动到想要大小写转换的地方然后键入: 个数 + ‘<del>‘。如:转换(大写转小写，小写转大写)10个字母:`10</del>`</li></ul><h2 id="转换一个单词"><a href="#转换一个单词" class="headerlink" title="转换一个单词"></a>转换一个单词</h2><p>将小写单词转换为大写单词：<code>gUw</code></p><p>将大写单词转换为小写：<code>guw</code></p><p>将单词中的大写改为小写，将小写改为大写：<code>g~w</code></p><p>其中：</p><ul><li><code>gu</code>表示把选定范围全部小写</li><li><code>gU</code>表示把选定范围全部大写</li><li><code>w</code>表示选定范围为单词</li></ul><p>依此类推，<code>ggguG</code>表示把整篇文章转换为小写，<code>gg</code>表示光标移动到文章开头，<code>G</code>表示选定范围为到文章结尾</p><h2 id="转换一行"><a href="#转换一行" class="headerlink" title="转换一行"></a>转换一行</h2><p>将整行转换为小写：<code>guu</code>。</p><p>将整行转换为大写：<code>gUU</code>。</p><p>将一行中的大写转换为小写，将小写转换为大写：<code>g~~</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>gu</code>和<code>gU</code>分别表示转换为小写和大写，后面跟转换范围，比如<code>5w</code>（5个单词）等。</p>]]></content>
    
    
    <summary type="html">VIM提供了字符大小写转换的快捷键，在coding的时候会感觉很贴心，当然，前提是记住他们。
</summary>
    
    
    
    <category term="Linux" scheme="http://zh-liang-cn.github.io/categories/Linux/"/>
    
    
    <category term="vim" scheme="http://zh-liang-cn.github.io/tags/vim/"/>
    
  </entry>
  
</feed>
