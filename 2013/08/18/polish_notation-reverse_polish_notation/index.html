<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>波兰式、逆波兰式与表达式求值 | 周亮的博客</title><meta name="description" content="波兰式、逆波兰式与表达式求值 - Liang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="周亮的博客"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="周亮的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="周亮的博客">周亮的博客</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/zh-liang-cn/" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">波兰式、逆波兰式与表达式求值</h1><div class="post-info"><a></a>2013-08-18</div><div class="post-content"><p>波兰式、逆波兰式是《数据结构》课程中讲解关于栈的时候提到的，栈是很简单的一种数据结构。但是这些理论的提出却是计算机早期发展领域的重大突破，值得仔细回味。</p>
<h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><p>我们在数学中学到的表达式被称为中缀表达式，操作符号在操作数中间，比如 <code>2 + 3 * (5 - 1)</code>。对人类而言，这种表达方式显而易见，求值也很直接，先算乘除再算加减，先算括号内再算括号外。<br>然而，这个表达式对于计算机而言却很费解。你可能会有疑问：这有什么难理解的嘛，在JavaScript、Python或者Ruby，甚至是<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/2605032/using-eval-in-java">Java</a>里面都可以通过<code>eval(&quot;2 + 3 * (5 - 1)&quot;)</code>来计算这个表达式。当然，这里的计算机并不是指现而今强大的计算机和高级编程语言，而是指上个世纪中页还处于发展初期的计算机。</p>
<h2 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h2><p>早在1920年，波兰科学家<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Jan_%C5%81ukasiewicz">扬&middot;武卡谢维奇</a>就发明了一种<strong>不需要括号</strong>的表示法，可以用来表示一个计算表达式。即将操作符号写在操作数之前，也就是前缀表达式，即波兰式（Polish Notation, PN）。这种表达式直到1960年计算机出现后才发挥出其威力。</p>
<p>比如<code>2 + 3 * (5 - 1)</code>这个表达式的前缀表达式为<code>+ 2 * 3 - 5 1</code>来表示。<br>阅读这个表达式需要从左至右读入表达式，如果一个操作符后面跟着两个操作数时，则计算，然后将结果作为操作数替换这个操作符和两个操作数，重复此步骤，直至所有操作符处理完毕。从左往右依次读取，直到遇到<code>- 5 1</code>，做计算后，将表达式替换为<code>+ 2 * 3 4</code>，然后从左往右再次读取，直到遇到<code>* 3 4</code>，做计算后将表达式替换为<code>+ 2 12</code>，然后从左往右依次读取，读到<code>+ 2 12</code>，计算得到14，到此结束。<br>可以看到，这种计算过程也相当复杂，需要多次遍历表达式，而且需要识别_一个操作符后面跟着两个操作数_这种模式，相比而言，下文中的逆波兰式要更为直接和简单。</p>
<p>如果你熟悉各种编程语言的话，这很像Lisp语言中的表达式（<a target="_blank" rel="noopener" href="http://clojure.org/getting_started">如下代码</a>）。需要注意的是，Lisp语言中的括号并不是数学意义上的的括号，Lisp中的函数是可以携带多个参数的，比如<code>(+ 1 2 3)</code>，因此需要使用括号来标明函数参数。</p>
<pre><code>Clojure 1.5.1
user=&gt; (+ 2 (* 3 (- 5 1)))
14
</code></pre>
<h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><p>后缀表达式也称为<strong>逆波兰式</strong>（Reverse Polish Notation, RPN），更加广为人知一些，和前缀表达式刚好相反，是将操作符号放置于操作数之后，比如<code>2 + 3 * (5 - 1)</code>用逆波兰式来表示则是：<code>2 3 5 1 - * +</code>。</p>
<p>逆波兰式的计算也是从左往右依次读取，当读到操作符时，将之前的两个操作数做计算，然后替换这两个操作数和操作符，接着读取，重复此步骤。对于这个表达式，读到<code>5 1 -</code>，得到<code>4</code>，然后读取乘号，取出前面的<code>3</code>和上一步的计算结果<code>4</code>，并计算，到<code>12</code>，接着读取加号<code>+</code>，计算<code>2 12 +</code>得到<code>14</code>，计算结束。<br>上面这个步骤可以很容易的用栈来实现：</p>
<blockquote>
<p>从左往右依次读取表达式，如果是数字则将该数字压栈，如果是符号，则将之前的两个数字出栈，做计算后，将计算结果压栈，直到表达式读取结束。栈中剩下的一个数就是计算结果。</p>
</blockquote>
<p>逆波兰式看起来像波兰式反过来，比如<code>5 + 1</code>的波兰式是<code>+ 5 1</code>，逆波兰式为<code>5 1 +</code>或者<code>1 5 +</code>。也很明显，逆波兰式并不是简单的将波兰式反过来，因为，减法和除法中减数和被减数、除数与被除数是不能交换的，即<code>- 10 5</code>和<code>- 5 10</code>就完全不一样。</p>
<h2 id="中缀表达式到后缀表达式的转换"><a href="#中缀表达式到后缀表达式的转换" class="headerlink" title="中缀表达式到后缀表达式的转换"></a>中缀表达式到后缀表达式的转换</h2><p>因为通过后缀表达式来进行计算只需要一个栈即可，从硬件和软件上实现都是极为便利的，因此逆波兰式在计算机领域的应用更加广泛，因此将中缀表达式转换为逆波兰式非常重要。<br>依然仅仅使用栈就可以将中缀表达式转换成逆波兰式，转换过程如下：</p>
<blockquote>
<p>从左往右遍历中缀表达式中的每个数字和符号，弱是数字就输出，成为逆波兰式的一部分； 如果是右括号，或者是其他符号并且比当前栈顶符号的优先级低，则栈顶元素依次出栈并输出； 然后将当前符号进栈，重复以上操作直到结束。</p>
</blockquote>
<p>还是以<code>2 + 3 * (5 - 1)</code>为例：</p>
<ul>
<li>首先读入数字<code>2</code>，直接将其输出，输出为<code>2</code>，栈为空</li>
<li>接着读入加号<code>+</code>，由于栈为空，因此将其进栈，输出为<code>2</code>，栈为<code>+</code></li>
<li>接着读入数字<code>3</code>，直接将其输出，输出为<code>2 3</code>，栈为<code>+</code></li>
<li>接着读入乘号<code>*</code>，比栈顶元素优先级高，进栈，输出为<code>2 3</code>，栈为<code>+ *</code></li>
<li>读入左括号<code>(</code>，直接进栈，输出<code>2 3</code>，栈为<code>+ * (</code></li>
<li>读入数字<code>5</code>，直接将其输出，输出为<code>2 3 5</code>，栈为<code>+ * (</code></li>
<li>读入减号<code>-</code>，栈顶元素为左括号，进栈，输出为<code>2 3 5</code>，栈为<code>+ * ( -</code></li>
<li>读入数字<code>1</code>，直接将其输出，输出为<code>2 3 5 1</code>，栈为<code>+ * ( -</code></li>
<li>读入右括号，依次输出栈顶元素，直到左括号，括号不输出，输出<code>2 3 5 1 -</code>，栈为<code>+ *</code></li>
<li>已经无元素可读，依次输出栈顶元素，直到栈为空，输出<code>2 3 5 1 - * +</code>，栈为空</li>
</ul>
<p>这样可以仅仅使用栈，首先将中缀表达式转换为逆波兰式，然后用本文第3节中的方法对后缀表达式进行求值，整个过程使用栈来完成即可。</p>
<h2 id="表达式树与逆波兰式"><a href="#表达式树与逆波兰式" class="headerlink" title="表达式树与逆波兰式"></a>表达式树与逆波兰式</h2><p>还可以通过另外一种方法来将一个表达式转换成波兰式和逆波兰式，这种方法依赖与树，首先需要根据表达式构建成树，仍然以<code>2 + 3 * (5 - 1)</code>为例，下图是其表达式树。</p>
<p><a target="_blank" rel="noopener" href="https://www.flickr.com/photos/zhlwish/14186573746/" title="Flickr 上 zhlwish 的 RPN-Tree-New-Page"><img src="https://farm3.staticflickr.com/2911/14186573746_896714d964_o.png" width="360" height="326" alt="RPN-Tree-New-Page"></a></p>
<p>我们发现这个树的后序遍历结果为<code>2 3 5 1 - * +</code>，刚好是其逆波兰式；而其先序遍历结果为<code>+ 2 * 3 - 5 1</code>刚好为其波兰式；中序遍历就不用说了，就是我们常见的中缀表达式。我们也可以通过这种特性来实现表达式的各种表示方法的转换。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波兰表示法</a></li>
<li><a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">波兰表示法</a></li>
<li><a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95">调度场算法</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/stay-foolish/archive/2012/04/25/2470590.html">将表达式转换成逆波兰式</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2013/08/26/https-ssl-rsa/">prev</a><a class="next" href="/2013/07/06/bpm-jbpm-activiti/">next</a></div><div class="copyright"><p>&copy; 2012 - 2021 <a href="https://zh-liang-cn.github.io">Liang</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>