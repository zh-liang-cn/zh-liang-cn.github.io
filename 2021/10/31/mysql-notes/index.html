<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>MySQL必知必会 | 周亮的博客</title><meta name="description" content="MySQL必知必会 - Liang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="周亮的博客"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="周亮的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="周亮的博客">周亮的博客</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/zh-liang-cn/" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">MySQL必知必会</h1><div class="post-info"><a></a>2021-10-31</div><div class="post-content"><blockquote>
<p>这是累积的需要在日常工作中用到的MySQL语句</p>
</blockquote>
<h2 id="查看数据库和表"><a href="#查看数据库和表" class="headerlink" title="查看数据库和表"></a>查看数据库和表</h2><p>查看所有的数据库、当前数据库中所有表，显示表的schema的语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line">USE <span class="operator">&lt;</span>database<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<p>为了和 Oracle 兼容，MySQL 提供了 <code>describe</code> 和 <code>desc</code> 语句，和 <code>show columns</code> 语句一样</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">DESC</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<p>显示创建表的语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>指定存储引擎，虽然不指定ENGINE会使用默认的InnoDB，但是数据库高手都是指定ENGINE的，因为不同用途的表的性能会因使用引擎的不同而不同。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> my_tbl() ENGIN<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> my_tbl() ENGIN<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>CREATE TABLE … SELECT 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_tbl <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orig_tbl;</span><br></pre></td></tr></table></figure>

<p>创建约束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product (</span><br><span class="line">     category <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">     id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     price <span class="type">DECIMAL</span>,</span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY (category, id)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">     id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product_order (</span><br><span class="line">     <span class="keyword">no</span> <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">     product_category <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     product_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     customer_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY (<span class="keyword">no</span>),</span><br><span class="line">     INDEX (product_category, product_id),</span><br><span class="line">     INDEX (customer_id),</span><br><span class="line"></span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY (product_category, product_id)</span><br><span class="line">          <span class="keyword">REFERENCES</span> product(category, id)</span><br><span class="line">          <span class="keyword">ON</span> UPDATE CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT,</span><br><span class="line"></span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY (customer_id)</span><br><span class="line">          <span class="keyword">REFERENCES</span> customer(id)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB;</span><br></pre></td></tr></table></figure>

<p>也可以这样写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product_order (</span><br><span class="line">     <span class="keyword">no</span> <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">     product_category <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     product_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     customer_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">     <span class="keyword">CONSTRAINT</span> pk_product_order <span class="keyword">PRIMARY</span> KEY (<span class="keyword">no</span>),</span><br><span class="line">     INDEX (product_category, product_id),</span><br><span class="line">     INDEX (customer_id),</span><br><span class="line"></span><br><span class="line">     <span class="keyword">CONSTRAINT</span> fk_product_order_product <span class="keyword">FOREIGN</span> KEY (product_category, product_id)</span><br><span class="line">          <span class="keyword">REFERENCES</span> product(category, id)</span><br><span class="line">          <span class="keyword">ON</span> UPDATE CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT,</span><br><span class="line"></span><br><span class="line">     <span class="keyword">CONSTRAINT</span>  fk_product_order_customer <span class="keyword">FOREIGN</span> KEY (customer_id)</span><br><span class="line">          <span class="keyword">REFERENCES</span> customer(id)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB; </span><br></pre></td></tr></table></figure>

<p>注意下面两点：</p>
<ol>
<li>这里的<code>constraint</code>是可选的，后面的<code>constraint name</code>也是可选的。</li>
<li>可以用于<code>primary key</code>, <code>foreign key</code>, <code>unique key</code>，即：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constraint</span> pk_name <span class="keyword">primary</span> key(id)</span><br><span class="line"><span class="keyword">constraint</span> fk_name <span class="keyword">foreign</span> key (fk_id) <span class="keyword">references</span> fk_table(id)</span><br><span class="line"><span class="keyword">constraint</span> uk_name <span class="keyword">unique</span> [index<span class="operator">|</span>key] index_name index_type...</span><br></pre></td></tr></table></figure>

<p>其他有用的语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] tbl_name;</span><br></pre></td></tr></table></figure>
<p>这里TABLE是可选的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">&#x27;file_name&#x27;</span> </span><br><span class="line">     [REPLACE <span class="operator">|</span> IGNORE]</span><br><span class="line">     <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tbl_name</span><br></pre></td></tr></table></figure>

<h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>修改表名:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">old</span> <span class="keyword">table</span> name<span class="operator">&gt;</span> rename <span class="operator">&lt;</span><span class="keyword">new</span> <span class="keyword">table</span> name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<p>添加列:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="keyword">add</span> <span class="keyword">column</span> <span class="operator">&lt;</span><span class="keyword">new</span> <span class="keyword">column</span> name<span class="operator">&gt;</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>删除列:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> <span class="keyword">drop</span> <span class="keyword">column</span> <span class="operator">&lt;</span><span class="keyword">column</span> name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<p>修改列类型:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> modify <span class="operator">&lt;</span><span class="keyword">column</span> name<span class="operator">&gt;</span> <span class="type">char</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">--或者</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> change <span class="operator">&lt;</span><span class="keyword">column</span> name<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">column</span> name<span class="operator">&gt;</span> <span class="type">char</span>(<span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<p>修改列名称：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span> change <span class="keyword">column</span> <span class="operator">&lt;</span><span class="keyword">old</span> <span class="keyword">column</span> name<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">new</span> <span class="keyword">column</span> name<span class="operator">&gt;</span> <span class="type">varchar</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<h2 id="备份和还原数据库"><a href="#备份和还原数据库" class="headerlink" title="备份和还原数据库"></a>备份和还原数据库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h localhost -u root -p123456 www &gt; data-backup.sql</span><br></pre></td></tr></table></figure>
<p>注意：-p后面没有空格，www是数据库名字，该命令会备份整个数据库www到d盘</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h localhost -u root -p123456 &lt;database&gt; &lt;table 1&gt; &lt;table 2&gt; &gt; data-backup.sql</span><br></pre></td></tr></table></figure>
<p>注意：备份<database>数据库的&lt;table 1&gt;和&lt;table 2&gt;表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h localhost -u root -p123456 –databases &lt;database 1&gt; &lt;database 2&gt; &lt;database 3&gt; &gt; data-backup.sql</span><br></pre></td></tr></table></figure>

<p>注意：备份三个数据库&lt;database 1&gt;，&lt;database 2&gt;，&lt;database 3&gt;中的所有表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h localhost -u root -p123456 &lt;database&gt; &lt;table&gt; --where=&quot;UPDATED_AT&gt;&#x27;2013-01-01&#x27;&quot; &gt; data-backup.sql</span><br></pre></td></tr></table></figure>

<p>注意：这里的<code>--where</code>可以对原来表中的数据进行筛选</p>
<p>其他参数：</p>
<ul>
<li><code>--no-data</code> 只导出schema，不导出数据</li>
</ul>
<p>还原数据库备份文件，常用<code>source</code>命令。进入mysql数据库控制台，然后使用<code>source</code>命令，后面参数为脚本文件（如这里用到的d:\wcnc_db.sql）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">mysql&gt;use 数据库</span><br><span class="line">mysql&gt;source d:\wcnc_db.sql</span><br></pre></td></tr></table></figure>

<p>也可以这样将details.sql文件中的数据导入到database数据库中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -h localhost -u root &lt;database&gt; &lt; details.sql</span><br></pre></td></tr></table></figure>

<h2 id="修改MySQL密码"><a href="#修改MySQL密码" class="headerlink" title="修改MySQL密码"></a>修改MySQL密码</h2><p>用这个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root -p password</span><br></pre></td></tr></table></figure>
<p>输入命令后会提示你输入当前root的密码，然后会让你输入新密码</p>
<p>注意：mysqladmin的命令格式是</p>
<p>mysqladmin [options] [command]</p>
<p>因此这个命令中的password是一个command，前面的”-u root -p”是options</p>
<p>如果当前没有root密码，需要给root账户添加密码，则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root password</span><br></pre></td></tr></table></figure>

<p>输入命令后，会提示你输入新的密码。</p>
<h2 id="MySQL用户和权限设置"><a href="#MySQL用户和权限设置" class="headerlink" title="MySQL用户和权限设置"></a>MySQL用户和权限设置</h2><p>创建一个数据库、一个用户，并且赋予用户控制这个数据库的权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="operator">&lt;</span>database name<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">user</span> <span class="string">&#x27;&lt;username&gt;&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;&lt;password&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> privileges <span class="keyword">ON</span> <span class="operator">&lt;</span>database name<span class="operator">&gt;</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;&lt;username&gt;&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>删除用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;&lt;username&gt;&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br></pre></td></tr></table></figure>

<p>也可以直接删除mysql.user表中的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;&lt;username&gt;&#x27;</span> <span class="keyword">and</span> host<span class="operator">=</span><span class="string">&#x27;&lt;from host&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>不过两者是有区别的。</p>
<p>查看权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意：‘root‘@’localhost’和‘root‘@’%’对于MySQL而言是两个不同的用户，前者只能从本机登录，后者可以从任何一台机器登录</p>
<p>赋予权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;&lt;username&gt;&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;&lt;password&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="operator">&lt;</span>db_name<span class="operator">&gt;</span>.<span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> <span class="keyword">to</span> <span class="string">&#x27;&lt;username&gt;&#x27;</span>@<span class="string">&#x27;&lt;from host&gt;&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;&lt;password&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>执行了最后一句flush privileges后，权限才会生效。</p>
<p>不常见的权限：</p>
<ol>
<li>GRANT_OPTION 执行grant语句的权限</li>
<li>REPLICATION_CLIENT 执行show master status、show slave status以及show binary logs的权限</li>
<li>REPLICATION_SLAVE 连接到master上的replication user必须具有的权限</li>
<li>SHUTDOWN 执行mysqladmin shutdown的权限</li>
<li>SUPER 拥有change master to, kill的权限，同时即使当前连接数超过了max_connections的限制，也可以连接到MySQL服务器</li>
</ol>
<p>如果是只读帐号，最好设成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">show</span> <span class="keyword">view</span> <span class="keyword">on</span> just_test.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;ro&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>其中show view权限是让用户执行show create view(对于view来讲，也可以用show create table)，用一些客户端的时候，会有自动提示，这类软件会用show create view来读取视图结构，因此最好把这个权限也赋给只读用户。</p>
<p>其他修改密码的方法：</p>
<ol>
<li>通过修改MYSQL数据库中MYSQL库的USER表，就用普通的UPDATE、INSERT语句就可以</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> Password<span class="operator">=</span>password(<span class="string">&#x27;newpassword&#x27;</span>) <span class="keyword">where</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>; </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用SET PASSWORD语句，</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> myuser<span class="variable">@localhost</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;mypasswd&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用GRANT … IDENTIFIED BY语句</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> myuser<span class="variable">@localhost</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mypassword&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>完了之后要执行：<code>flush privileges;</code></p>
<h2 id="对表进行分析"><a href="#对表进行分析" class="headerlink" title="对表进行分析"></a>对表进行分析</h2><p>命令语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure>

<p>analyze命令会更新表的统计信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status [<span class="keyword">from</span> <span class="operator">&lt;</span>database name<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure>

<p>输出为一个表格，因此我们可以用where语句来筛选，显示表名以INV开头的表的状态</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;INV_%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意：analyze table 命令会使用索引的信息来更新table的统计信息，对myisam表执行这个命令的时候会扫描整个索引，也就是说会锁住table一段时间。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://www.mysqlperformanceblog.com/2008/09/02/beware-of-running-analyze-in-production/">http://www.mysqlperformanceblog.com/2008/09/02/beware-of-running-analyze-in-production/</a></p>
<p>因此，看起来analyze table应该是一个非常快的命令，并且是无侵入性（non intrusive）的命令。</p>
<p>实际上不是，因为<code>analyze table</code>会等待之前所有的table的cache都flush到磁盘后才能进行统计，同时，<code>analyze table</code>本身也持有一个排他锁，详见：<a target="_blank" rel="noopener" href="http://bugs.mysql.com/bug.php?id=33278">http://bugs.mysql.com/bug.php?id=33278</a></p>
<p>也就是说，如果当前正在在innodb table上执行一个很长的query，你的analyze table会阻塞在“waiting for table”锁上，直到这个query执行完成。</p>
<p>执行完analyze table后，可以查看索引的状态。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="http://www.penglixun.com/tech/database/mysql_show_index_cardinality.html">http://www.penglixun.com/tech/database/mysql_show_index_cardinality.html</a></p>
<p>会显示如下字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment |</span><br></pre></td></tr></table></figure>

<p>Cardinality列的含义，查看官方文档的解释：</p>
<p>An estimate of the number of unique values in the index. This is updated by running ANALYZE TABLE or myisamchk -a. Cardinality is counted based on statistics stored as integers, so the value is not necessarily exact even for small tables. The higher the cardinality, the greater the chance that MySQL uses the index when doing joins.</p>
<p>所以这个Cardinality会有如下的含义：</p>
<ol>
<li>列值代表的是此列中存储的唯一值的个数（如果此列为primary key 则值为记录的行数）</li>
<li>列值只是个估计值，并不准确。ANALYZE: MyISAM vs Innodb - MySQL Performance Blog 中可以看出来这个值有多么不靠谱</li>
<li>列值不会自动更新，需要通过Analyze table来更新一张表或者mysqlcheck -Aa来进行更新整个数据库。</li>
<li>列值的大小影响Join时是否选用这个Index的判断。</li>
<li>创建Index时，MyISAM的表Cardinality的值为null，InnoDB的表Cardinality的值大概为行数。</li>
<li>MyISAM与InnoDB对于Cardinality的计算方式不同。 </li>
</ol>
<h2 id="MySQL主从复制配置"><a href="#MySQL主从复制配置" class="headerlink" title="MySQL主从复制配置"></a>MySQL主从复制配置</h2><p>详见：<a href="https://zh-liang-cn.github.io/2014/01/19/mysql-master-slave-replication/">https://zh-liang-cn.github.io/2014/01/19/mysql-master-slave-replication/</a></p>
<h2 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h2><p>先看示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- create table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_details(</span><br><span class="line">     id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">     user_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     first_name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     last_name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     birth_date <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     age <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY (id, birth_date),</span><br><span class="line">     KEY full_name (`user_id`, `first_name`, `last_name`)</span><br><span class="line">) </span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> HASH(<span class="keyword">YEAR</span>(birth_date))</span><br><span class="line">PARTITIONS <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个表，按照birth_date的year进行分区，分成4个区，编号分别为p1, p2, p3, p4。</p>
<p>可以通过<code>explain</code>来查看数据在哪个分区上：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- explain query</span></span><br><span class="line">EXPLAIN PARTITIONS </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_details</span><br><span class="line"><span class="keyword">WHERE</span> birth_date <span class="operator">=</span> <span class="string">&#x27;2014-09-11&#x27;</span></span><br><span class="line">     <span class="keyword">AND</span> user_id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">     <span class="keyword">AND</span> first_name <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>因为我们查询的YEAR(birth_date)为2014，除4后余2，因此所在数据所在分区为p2。</p>
<p>可以看出这个SQL用了索引，当分区字段做为条件传递的时候就会只在相应的分区内做查询了，可以有效减少扫描的索引结点以及数据行。</p>
<h3 id="分区函数"><a href="#分区函数" class="headerlink" title="分区函数"></a>分区函数</h3><p>Partition function有4种: </p>
<ol>
<li>RANGE</li>
<li>LIST</li>
<li>[LINEAR] HASH</li>
<li>[LINEAR] KEY</li>
</ol>
<p>其返回值为整数，代表分区的编号，而且Partition function不能返回常数或者随机值</p>
<p>Partition function要求partition expression中可以包含一个或者多个列名，这种分区方式称为horizontal partitioning，也就是将不同的行分配到不同的物理分区上。</p>
<p>还有一种分区方式称为“垂直分区”，指将不同的列分配到不同的分区上，但是在MySQL 5.5中还没有实现</p>
<p>Mysql一个表的所有分区的storage engine必须相同，但是同一个database的不同表可以用不同的storage engine。</p>
<p>Mysql的merge, csv, federated引擎不支持分区。</p>
<p>特别注意：如果一个表没有主键，那么分区字段可以为任何字段；如果一个表有主键，那么分区字段必须是主键的一部分。也就是说下面这样是不行的，会报错：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_with_primary_key (</span><br><span class="line">     c1 <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">     c2 <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> COLUMNS (c2) (</span><br><span class="line"><span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;b&#x27;</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;c&#x27;</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<h3 id="RANGE分区类型"><a href="#RANGE分区类型" class="headerlink" title="RANGE分区类型"></a>RANGE分区类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    fname <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    lname <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    hired <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1970-01-01&#x27;</span>,</span><br><span class="line">    separated <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;9999-12-31&#x27;</span>,</span><br><span class="line">    job_code <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    store_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (store_id) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">11</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="number">16</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>VALUES LESS THAN 后面也可以接表达式，只需要能MySQL能计算出这个表达式的值，并且这个值和这个字段能比较就可以了</p>
<p>按年分区：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    fname <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    lname <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    hired <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1970-01-01&#x27;</span>,</span><br><span class="line">    separated <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;9999-12-31&#x27;</span>,</span><br><span class="line">    job_code <span class="type">INT</span>,</span><br><span class="line">    store_id <span class="type">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> ( <span class="keyword">YEAR</span>(separated) ) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1991</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1996</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2001</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>按UNIX_TIMESTAMP分区：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> quarterly_report_status (</span><br><span class="line">    report_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    report_status <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    report_updated <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> ( UNIX_TIMESTAMP(report_updated) ) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="string">&#x27;2008-01-01 00:00:00&#x27;</span>) ),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="string">&#x27;2008-04-01 00:00:00&#x27;</span>) ),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="string">&#x27;2008-07-01 00:00:00&#x27;</span>) ),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="string">&#x27;2008-10-01 00:00:00&#x27;</span>) ),</span><br><span class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="string">&#x27;2009-01-01 00:00:00&#x27;</span>) ),</span><br><span class="line">    <span class="keyword">PARTITION</span> p5 <span class="keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="string">&#x27;2009-04-01 00:00:00&#x27;</span>) ),</span><br><span class="line">    <span class="keyword">PARTITION</span> p6 <span class="keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="string">&#x27;2009-07-01 00:00:00&#x27;</span>) ),</span><br><span class="line">    <span class="keyword">PARTITION</span> p7 <span class="keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="string">&#x27;2009-10-01 00:00:00&#x27;</span>) ),</span><br><span class="line">    <span class="keyword">PARTITION</span> p8 <span class="keyword">VALUES</span> LESS THAN ( UNIX_TIMESTAMP(<span class="string">&#x27;2010-01-01 00:00:00&#x27;</span>) ),</span><br><span class="line">    <span class="keyword">PARTITION</span> p9 <span class="keyword">VALUES</span> LESS THAN (MAXVALUE)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>注意TimeStamp字段是不能用于分区的，Bug #42849</p>
<p>RANGE分区的好处：</p>
<ol>
<li>如果你想删除旧的数据，可以直接删除这个分区：alter table employees drop partition p0;，这比delete from要高效很多</li>
<li>你需要一列包含日期或者时间数值，或者包含从其他字段计算出来的值</li>
<li>你经常执行query中包含用于分区的列，比如EXPLAIN PARTITIONS SELECT COUNT(*) FROM employees WHERE separated BETWEEN ‘2000-01-01’ AND ‘2000-12-31’ GROUP BY store_id;</li>
</ol>
<h3 id="LIST分区类型"><a href="#LIST分区类型" class="headerlink" title="LIST分区类型"></a>LIST分区类型</h3><p>和RANGE很像，RANGE里面的每个值必须是连续的，LIST则可以是离散的，当然，同样都只能是整数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    fname <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    lname <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    hired <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1970-01-01&#x27;</span>,</span><br><span class="line">    separated <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;9999-12-31&#x27;</span>,</span><br><span class="line">    job_code <span class="type">INT</span>,</span><br><span class="line">    store_id <span class="type">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> LIST(store_id) (</span><br><span class="line">    <span class="keyword">PARTITION</span> pNorth <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">17</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> pEast <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">19</span>,<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> pWest <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">4</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">18</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> pCentral <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>好处：删除旧数据ALTER TABLE employees TRUNCATE PARTITION pWest </p>
<p>注意：ALTER TABLE XXX TRUNCATE PARTITION是清空分区中的数据，不删除分区，ALTER TABLE XXX DROP PARTITION会删除分区，当然可以通过ALTER TABLE XXX ADD PARTITION再加回来</p>
<p>和RANGE的一个区别：LIST没有那种catch all的分区，如果你添加一个MySQL无法分区的值，就会报错，可以用insert ignore</p>
<h3 id="COLUMNS分区类型"><a href="#COLUMNS分区类型" class="headerlink" title="COLUMNS分区类型"></a>COLUMNS分区类型</h3><p>有两种：RANGE COLUMNS和LIST COLUMNS, MySQL 5.5.0才引入。</p>
<p>使用COLUMNS分区方式可以使用多个列进行分区，而且列的类型不仅仅是整数：</p>
<ol>
<li>整数类型：TINYINT, SMALLINT, MEDIUMINT, INT(INTGER), BIGINT，特别注意：FLOAT和DECIMAL不支持分区</li>
<li>时间类型：DATE, DATETIME</li>
<li>字符类型：CHAR, VARCHAR, BINARY, VARBINARY，特别注意：TEXT和BLOB不支持分区</li>
</ol>
<h3 id="RANGE-COLUMNS分区类型"><a href="#RANGE-COLUMNS分区类型" class="headerlink" title="RANGE COLUMNS分区类型"></a>RANGE COLUMNS分区类型</h3><p>不支持表达式，只支持列名；可以输入多个列，MySQL会执行基于元组（Tuple）的比较；不仅仅局限于使用整数型列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> rcx (</span><br><span class="line">    a <span class="type">INT</span>,</span><br><span class="line">    b <span class="type">INT</span>,</span><br><span class="line">    c <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">    d <span class="type">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> COLUMNS(a,d,c) (</span><br><span class="line">     <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">5</span>,<span class="number">10</span>,<span class="string">&#x27;ggg&#x27;</span>),</span><br><span class="line">     <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">10</span>,<span class="number">20</span>,<span class="string">&#x27;mmmm&#x27;</span>),</span><br><span class="line">     <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="number">15</span>,<span class="number">30</span>,<span class="string">&#x27;sss&#x27;</span>),</span><br><span class="line">     <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>由于COLUMNS分区可以用来分区非整数型的字段，所以像下面这种做法也是可以的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees_by_lname (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    fname <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    lname <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    hired <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1970-01-01&#x27;</span>,</span><br><span class="line">    separated <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;9999-12-31&#x27;</span>,</span><br><span class="line">    job_code <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    store_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> COLUMNS (lname)  (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;m&#x27;</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;t&#x27;</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN (MAXVALUE)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<h3 id="LIST-COLUMNS"><a href="#LIST-COLUMNS" class="headerlink" title="LIST COLUMNS"></a>LIST COLUMNS</h3><p>结合两个看就明白了</p>
<h3 id="HASH分区类型"><a href="#HASH分区类型" class="headerlink" title="HASH分区类型"></a>HASH分区类型</h3><p>之前的几种分区方式，都需要显示的指定行存放的分区的位置，但是HASH就不用了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    fname <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    lname <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    hired <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1970-01-01&#x27;</span>,</span><br><span class="line">    separated <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;9999-12-31&#x27;</span>,</span><br><span class="line">    job_code <span class="type">INT</span>,</span><br><span class="line">    store_id <span class="type">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> HASH(store_id)</span><br><span class="line">PARTITIONS <span class="number">4</span>; </span><br></pre></td></tr></table></figure>

<p>如果没指定PARTITIONS的值，默认为1，就是没分区</p>
<p>HASH分区函数接受任何可以返回整数值的表达式作为参数，但是因为每次插入都会执行这个语句，太复杂的就不行了；同时，如果修改了行导致计算表达式返回的值变化了，也会导致行从一个分区中移动到另一个分区，因此，最好是选择稳定的列或者稳定的表达式，比如YEAR(xxx)就比TO_DAYS(xxx)强</p>
<h3 id="LINEAR-HASH分区类型"><a href="#LINEAR-HASH分区类型" class="headerlink" title="LINEAR HASH分区类型"></a>LINEAR HASH分区类型</h3><p>用了很复杂的算法，正态分布，好处在于添加、删除，合并、拆分分区很快，名字很容易误导人，LINEAR总是让然想起平均分</p>
<h3 id="KEY分区类型"><a href="#KEY分区类型" class="headerlink" title="KEY分区类型"></a>KEY分区类型</h3><p>Key分区和Hash分区是有区别的，Hash的分区函数可以看出来是用的整除，但是Key分区的分区函数是PASSWORD(),应该是散列，感觉Key和Hash的名字取反了吧，见<a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-20785090-id-4015547.html">http://blog.chinaunix.net/uid-20785090-id-4015547.html</a> 。</p>
<p>用于KEY分区函数的字段：</p>
<ol>
<li>可以是0个或者多个，如果是0个，则使用主键作为分区，如果没有主键但是有UNIQUE KEY，则会使用UNIQUE KEY</li>
<li>必须是表的主键的一部分</li>
<li>不局限于整数类型</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tm1 (</span><br><span class="line">    s1 <span class="type">CHAR</span>(<span class="number">32</span>) <span class="keyword">PRIMARY</span> KEY</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> KEY(s1)</span><br><span class="line">PARTITIONS <span class="number">10</span>; </span><br></pre></td></tr></table></figure>

<h3 id="LINEAR-KEY分区类型"><a href="#LINEAR-KEY分区类型" class="headerlink" title="LINEAR KEY分区类型"></a>LINEAR KEY分区类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tk (</span><br><span class="line">    col1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    col2 <span class="type">CHAR</span>(<span class="number">5</span>),</span><br><span class="line">    col3 <span class="type">DATE</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> LINEAR KEY (col1)</span><br><span class="line">PARTITIONS <span class="number">3</span>; </span><br></pre></td></tr></table></figure>

<h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts (id <span class="type">INT</span>, purchased <span class="type">DATE</span>)</span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>( <span class="keyword">YEAR</span>(purchased) )</span><br><span class="line">    SUBPARTITION <span class="keyword">BY</span> HASH( TO_DAYS(purchased) )</span><br><span class="line">    SUBPARTITIONS <span class="number">2</span> (</span><br><span class="line">        <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1990</span>),</span><br><span class="line">        <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2000</span>),</span><br><span class="line">        <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">    ); </span><br></pre></td></tr></table></figure>

<p>对于NULL的处理，在LIST和RANGE分区函数中，将NULL的值当作比non-NULL值小的值，因此，对于下面的分区：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">     c1 <span class="type">int</span>,</span><br><span class="line">     c2 <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span>(c1) (</span><br><span class="line">     <span class="keyword">partition</span> p0 <span class="keyword">values</span> less than (<span class="number">0</span>),</span><br><span class="line">     <span class="keyword">partition</span> p1 <span class="keyword">values</span> less than (<span class="number">10</span>),</span><br><span class="line">     <span class="keyword">partition</span> p2 <span class="keyword">values</span> less than MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入insert into t1 values(null, ‘liang’); 会到第一个分区。</p>
<p>对于LIST一般这么分：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">     c1 <span class="type">int</span>,</span><br><span class="line">     c2 <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> list(c1) (</span><br><span class="line">     <span class="keyword">partition</span> p0 <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>),</span><br><span class="line">     <span class="keyword">partition</span> p1 <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>),</span><br><span class="line">     <span class="keyword">partition</span> p2 <span class="keyword">values</span> <span class="keyword">in</span> (<span class="keyword">null</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果后面没有这个null语句，插入null会报错：<code>ERROR 1504 (HY000): Table has no partition for value NULL</code></p>
<p>对于HASH和KEY分区函数，如果字段的值为NULL或者表达式的值为NULL，则会当作0进行处理。</p>
<p>值得注意的是下面两语句都返回为NULL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NULL</span> MOD <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>对于表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> th(</span><br><span class="line">     c1 <span class="type">int</span>,</span><br><span class="line">     c2 <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> hash(c1)</span><br><span class="line">partitions <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果插入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> th(<span class="keyword">null</span>, <span class="string">&#x27;liang&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>将会放到p0分区</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>partition expression中：</p>
<ol>
<li>不能有存储过程、函数、UDF以及插件</li>
<li>不能声明变量以及使用自定义变量</li>
<li>可以有+ - *但是不能有 / 或者DIV，除了[LINEAR] KEY以外，只能返回整数值以及NULL</li>
<li>不能有位运算符，比如| &amp; ^ &lt;&lt; &gt;&gt; ~</li>
<li>不能有HEANLDER语句</li>
</ol>
<p>分区创建好之后最好不改变SQL_MODE，可能出现数据丢失的情况</p>
<h3 id="Table-locks"><a href="#Table-locks" class="headerlink" title="Table locks"></a>Table locks</h3><p>分区操作会获取写锁，不影响select，但是影响insert和update</p>
<p>最大的分区数（包括子分区）为1024，NDB引擎除外</p>
<p>对于已经分区的表，query cache不起作用了，MySQL 5.5对已经分区的表自动禁用query cache，Bug #53775</p>
<p>已经分区的InnoDB表，外键不再支持</p>
<p>详见：<a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.7/en/partitioning.html">http://dev.mysql.com/doc/refman/5.7/en/partitioning.html</a></p>
<h2 id="查看MySQL系统变量"><a href="#查看MySQL系统变量" class="headerlink" title="查看MySQL系统变量"></a>查看MySQL系统变量</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@hostname</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@version</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@server</span>_id;  </span><br></pre></td></tr></table></figure>

<p>注意：一个master-slave集群中的每台机器的server_id必须不同 </p>
<p>查看MySQL的data目录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;datadir&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>状态信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Created_tmp_%&#x27;</span>; </span><br><span class="line"><span class="keyword">show</span> session status;</span><br></pre></td></tr></table></figure>

<p>配置变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show global variables;</span><br><span class="line">show global status like &#x27;%_table_size&#x27;; </span><br><span class="line">show session variables;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL-TimeStamp类型"><a href="#MySQL-TimeStamp类型" class="headerlink" title="MySQL TimeStamp类型"></a>MySQL TimeStamp类型</h2><p>创建一个插入数据时自动更新的字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> posts(</span><br><span class="line">  id <span class="type">int</span> auto_increment,</span><br><span class="line">  title <span class="type">char</span>(<span class="number">80</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  post text <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  created_at <span class="type">timestamp</span> <span class="keyword">default</span> <span class="built_in">current_timestamp</span>,</span><br><span class="line">  updated_at datetime,</span><br><span class="line">  <span class="keyword">primary</span> key (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者将<code>created_at</code>那行换成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">created_at timestamp default now(),</span><br></pre></td></tr></table></figure>

<p>注意，MySQL5.6以前一个表是不能有两个自动更新时间的字段的，也就是说下面这个是会报错的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> posts(</span><br><span class="line">  id <span class="type">int</span> auto_increment,</span><br><span class="line">  title <span class="type">char</span>(<span class="number">80</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  post text <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">  created_at <span class="type">timestamp</span> <span class="keyword">default</span> <span class="built_in">current_timestamp</span>,</span><br><span class="line">  updated_at datetime <span class="keyword">default</span> now() <span class="keyword">on</span> update now(), </span><br><span class="line">  <span class="keyword">primary</span> key (id)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>不过MySQL5.6之后已经支持两个以上自动更新时间的字段了。</p>
<p>另外注意<code>updated_at</code>字段的：<code>on update now()</code>，当这一行被update后，这个时间戳会自动更新</p>
<h2 id="java-sql-SQLException-Value’0000-00-00’异常解决办法"><a href="#java-sql-SQLException-Value’0000-00-00’异常解决办法" class="headerlink" title="java.sql.SQLException: Value’0000-00-00’异常解决办法"></a>java.sql.SQLException: Value’0000-00-00’异常解决办法</h2><p>在使用MySql时, 数据库中的字段类型是timestamp的,默认为0000-00-00, 会发生异常:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.sql.SQLException:   Value &#x27;0000-00-00&#x27; can not be represented as java.sql.Timestamp</span><br></pre></td></tr></table></figure>

<p>解决办法:给jdbc url加上zeroDateTimeBehavior参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datasource.url=jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;transformedBitIsBoolean=true</span><br></pre></td></tr></table></figure>

<p><code>zeroDateTimeBehavior=round</code>是为了指定MySql中的<code>DateTime</code>字段默认值查询时的处理方式；默认是抛出异常，对于值为0000-00-00 00:00:00（默认值）的纪录，如下两种配置，会返回不同的结果：</p>
<ol>
<li>zeroDateTimeBehavior=round   0001-01-01   00:00:00.0</li>
<li>zeroDateTimeBehavior=convertToNull   null   </li>
</ol>
<h2 id="MySQL临时表"><a href="#MySQL临时表" class="headerlink" title="MySQL临时表"></a>MySQL临时表</h2><p>对于某些query，MySQL会创建临时表来进行处理，临时表有两种：</p>
<ol>
<li>基于MEMORY存储引擎的临时内存表</li>
<li>基于MyISAM存储引擎的临时磁盘表</li>
</ol>
<p>当临时内存表的大小达到一定限制的时候，MySQL就会将临时内存表写入到磁盘，变为临时磁盘表。</p>
<p>这个限制由<code>tmp_table_size</code>和<code>max_heap_table_size</code>这两个变量中的最小值确定。</p>
<p>注意，用于使用<code>create table</code>创建的内存表和这里提到的临时内存表不一样，前者的大小仅仅只受<code>max_heap_table_size</code>来限制，而且永远不会出现超过大小限制会写入到磁盘。</p>
<p>有这么几种情况会出现临时内存表：</p>
<ol>
<li>包含UNION的query；</li>
<li>使用了UNION或者聚合运算的视图，有个算法专门用于判定一个视图是不是会使用临时表：<a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.0/en/view-algorithms.html">http://dev.mysql.com/doc/refman/5.0/en/view-algorithms.html</a></li>
<li>如果query包含order by和group by子句，并且两个子句中的字段不一样；或者order by或者group by中包含除了第一张表中的字段；</li>
<li>query中同时包含distinct和order by<br>如果一个query的explain结果中的extra字段包含using temporary，说明这个query使用了临时表。</li>
</ol>
<p>当MySQL处理query是创建了临时表（不论是内存临时表还是磁盘临时表），<code>created_tmp_tables</code>变量都会增加。如果创建了磁盘临时表，<code>created_tmp_disk_tables</code>会增加。</p>
<p>可以通过<code>show session status like &#39;Created_tmp_%&#39;;</code>来查看，如果要查看全局的临时表使用次数，将其中的session改为global即可。</p>
<p>一般磁盘临时表会比内存临时表慢，因此要尽可能避免出现磁盘临时表。下面几种情况下，MySQL会直接使用磁盘内存表，要尽可能避免：</p>
<ol>
<li>表中包含了BLOB和TEXT字段（MEMORY引擎不支持这两种字段）；</li>
<li>group by和distinct子句中的有超过512字节的字段；</li>
<li>UNION以及UNION ALL语句中，如果SELECT子句中包含了超过512（对于binary string是512字节，对于character是512个字符）的字段。</li>
</ol>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.thegeekstuff.com/2008/09/backup-and-restore-mysql-database-using-mysqldump/">http://www.thegeekstuff.com/2008/09/backup-and-restore-mysql-database-using-mysqldump/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.kbedell.com/2009/03/07/how-to-create-a-timestampdatetime-column-in-mysql-to-automatically-be-set-with-the-current-time/">http://www.kbedell.com/2009/03/07/how-to-create-a-timestampdatetime-column-in-mysql-to-automatically-be-set-with-the-current-time/</a> </li>
<li><a target="_blank" rel="noopener" href="http://www.blogjava.net/hilor/articles/164814.html">http://www.blogjava.net/hilor/articles/164814.html</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="next" href="/2020/02/14/isolation-levels-in-database/">next</a></div><div class="copyright"><p>&copy; 2012 - 2021 <a href="https://zh-liang-cn.github.io">Liang</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>