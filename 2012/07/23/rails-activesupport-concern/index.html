<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>[Rails代码解读]ActiveSupport::Concern | 周亮的博客</title><meta name="description" content="[Rails代码解读]ActiveSupport::Concern - Liang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="周亮的博客"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="周亮的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="周亮的博客">周亮的博客</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/zh-liang-cn/" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">[Rails代码解读]ActiveSupport::Concern</h1><div class="post-info"><a></a>2012-07-23</div><div class="post-content"><p>Ruby的模块是一种类型，因此也有模块方法（相当于类方法）和实例方法（相当于实例方法），模块方法可以直接调用，而实例方法必须通过_include_混入到一个类中，才能由一个对象实例调用。</p>
<h2 id="模块方法和实例方法"><a href="#模块方法和实例方法" class="headerlink" title="模块方法和实例方法"></a>模块方法和实例方法</h2><p>模块是方法和常量的集合，模块和类一样，其中的可以包括两种方法：实例方法(Instance Method)、模块方法(Module Method)。当一个类混入(Mixin，本文中称混入)一个模块时，模块中的实例方法会成为该类的方法(具体是类的类方法还是实例方法，取决于是include还是extend)。但是模块方法会被忽略，而且，模块方法可以虽然定义在模块中，但是可以直接调用。</p>
<p>下面代码定义了Mod模块以及Clz类，Clz类include模块Mod</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Mod</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_instance</span></span></span><br><span class="line">        puts <span class="string">&#x27;Call: Instance Method&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    def <span class="keyword">self</span>.func_module</span><br><span class="line">        puts <span class="string">&#x27;Call: Module Method&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clz</span></span></span><br><span class="line">    <span class="keyword">include</span> Mod</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts <span class="string">&quot;Class Methods: <span class="subst">#&#123; Clz.methods.grep /^func/ &#125;</span>&quot;</span></span><br><span class="line">puts <span class="string">&quot;Instance Methods: <span class="subst">#&#123; Clz.instance_methods.grep /^func/ &#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<pre><code>Class Methods: []
Instance Methods: [:func_instance]
</code></pre>
<p>模块中定义的实例方法和模块方法的调用方法如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接调用模块的模块方法</span></span><br><span class="line">Mod::func_module</span><br><span class="line"><span class="comment"># 调用模块的实例方法必须创建Clz对象</span></span><br><span class="line">Clz.new.func_instance</span><br></pre></td></tr></table></figure>

<p>以上代码输出为：</p>
<pre><code>Call: Instance Method
Call: Module Method
</code></pre>
<h2 id="extend和include"><a href="#extend和include" class="headerlink" title="extend和include"></a>extend和include</h2><p>前节中定义的Clz类include混入了模块Mod，现在创建一个新类ClzNew，使用extend混入模块Mod。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClzNew</span></span></span><br><span class="line">    extend Mod</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">puts <span class="string">&quot;Class Methods: <span class="subst">#&#123; ClzNew.methods.grep /^func/ &#125;</span>&quot;</span></span><br><span class="line">puts <span class="string">&quot;Instance Methods: <span class="subst">#&#123; ClzNew.instance_methods.grep /^func/ &#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># func_isntance为ClzNew的类方法</span></span><br><span class="line">ClzNew.func_instance</span><br></pre></td></tr></table></figure>

<p>同样，打印ClzNew的类方法和实例方法，输出结果为：</p>
<pre><code>Class Methods: [:func_instance]
Instance Methods: []
Call: Instance Method
</code></pre>
<p>从上面的输出可以得到两点：</p>
<ul>
<li>模块方法<code>func_module</code>在混入的时候仍然被忽略</li>
<li>使用extend混入时，模块中的方法成为类的类方法，而使用include混入时，模块中的方法成为类的实例方法</li>
</ul>
<h2 id="included和append-features"><a href="#included和append-features" class="headerlink" title="included和append_features"></a>included和append_features</h2><p>当一个模块被其他类或者模块include时，<code>Module#included(parent)</code>会被调用，这个方法可以认为是一个回调函数(Callback)。而对于<code>Module#append_features</code>则是当include或者extend语句被执行时被调用，真正的将一个模块混入到另一个类或者模块中，不是回调函数，因此一个模块中覆盖(Override)<code>Module#append_features</code>时，必须使用<code>super</code>语句去真正的执行模块混入的操作，否则模块混入不会被真正的执行。</p>
<p>下面的语句，为之前定义的Mod模块添加了<code>included</code>方法，然后将其混入<code>ClzParent</code>中。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def Mod.included(parent)</span><br><span class="line">    puts <span class="string">&quot;<span class="subst">#&#123;<span class="keyword">self</span>&#125;</span> is included in <span class="subst">#&#123;parent&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClzParent</span></span></span><br><span class="line">  <span class="keyword">include</span> Mod</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">puts <span class="string">&quot;Class Methods: <span class="subst">#&#123; ClzParent.methods.grep /^func/ &#125;</span>&quot;</span></span><br><span class="line">puts <span class="string">&quot;Instance Methods: <span class="subst">#&#123; ClzParent.instance_methods.grep /^func/ &#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出如下，其中第一句证实了<code>included</code>方法在ClzParent类include模块Mod是被调用，而且<code>func_instance</code>成为了ClzParent类的实例方法。</p>
<pre><code>include: Mod is included in Clz
Class Methods: []
Instance Methods: [:func_instance]
</code></pre>
<p>接着对<code>append_features()</code>进行实验，需要注意的是<code>append_features()</code>方法中真正执行混入的<code>super</code>语句被注释了。因此可以预见，<code>Mod#func_instance()</code>不会成为类ClzParentNew的实例方法，而后面的输出也证实了这一点。输出也证明，<code>append_features()</code>被先调用，<code>include</code>被后调用。实际上，<code>include()</code>是在<code>append_features()</code>被调用的。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def Mod.included(parent)</span><br><span class="line">    puts <span class="string">&quot;<span class="subst">#&#123;<span class="keyword">self</span>&#125;</span> is included in <span class="subst">#&#123;parent&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">def Mod.append_features(parent)</span><br><span class="line">  puts <span class="string">&quot;append_features: <span class="subst">#&#123;<span class="keyword">self</span>&#125;</span> is included in <span class="subst">#&#123;parent&#125;</span>&quot;</span></span><br><span class="line">  <span class="comment"># super</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClzParentNew</span></span></span><br><span class="line">  <span class="keyword">include</span> Mod</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts <span class="string">&quot;Class Methods: <span class="subst">#&#123; ClzParentNew.methods.grep /^func/ &#125;</span>&quot;</span></span><br><span class="line">puts <span class="string">&quot;Instance Methods: <span class="subst">#&#123; ClzParentNew.instance_methods.grep /^func/ &#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<pre><code>append_features: Mod is included in ClzParentNew
include: Mod is included in ClzParentNew
Class Methods: []
Instance Methods: []
</code></pre>
<p>将上面代码中的super语句取消注释，<code>Mod#func_instance()</code>成为了类ClzParentNew的实例方法，输出变为如下：</p>
<pre><code>append_features: Mod is included in ClzParentNew
include: Mod is included in ClzParentNew
Class Methods: []
Instance Methods: [:func_instance]
</code></pre>
<p>因此，在通过append_features加入对include回调时，千万不能忘记用<code>super</code>来实现真正的include操作。</p>
<h2 id="Ruby混入的惯用方法"><a href="#Ruby混入的惯用方法" class="headerlink" title="Ruby混入的惯用方法"></a>Ruby混入的惯用方法</h2><p>为了将代码更好的模块化，Ruby的提供了不同类型的混入(include和extend)来实现混入类方法和实例方法。但是不管是类的类方法还是实例方法，最终都是模块的实例方法，因此，为了同时实现类方法和实例方法的混入，必须定义两个模块，然后分别include和extend，如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">ClassMethods</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">InstanceMethods</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">    extend ClassMethods</span><br><span class="line">    <span class="keyword">include</span> InstanceMethods</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>可能是觉得这种方法将模块的粒度分得太开(模块的划分粒度的确是个经常遇到问题)，因此在Ruby中出现了下面一种惯例，将类方法定义在一个子模块中，使用<code>included()</code>回调，这个子模块常常命名为<code>ClassMethods</code>。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Mod</span></span></span><br><span class="line">    def <span class="keyword">self</span>.included(base)</span><br><span class="line">        base.extend(ClassMothods)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="class"><span class="keyword">module</span> <span class="title">ClassMethods</span></span></span><br><span class="line">        <span class="comment"># 类方法定义</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">#实例方法定义</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line">    <span class="keyword">include</span> Mod</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>上面代码将实现了在Mod中同时定义类方法和实例方法。需要注意的是，即使在ClassMethods中定义的是类方法，也不能在方法前加<code>self</code>，否者，该方法会成为模块方法，混入时会被自动忽略了。</p>
<p>虽然这是一种很好的方法，但是每次都要编写这些代码，而且和DRY(Don’t Repeat Yourself])原则违背。</p>
<h2 id="模块混入的依赖问题"><a href="#模块混入的依赖问题" class="headerlink" title="模块混入的依赖问题"></a>模块混入的依赖问题</h2><p>正常情况下，Ruby会自动解决模块的依赖，比如B模块include模块A，C类include模块B，那么C类也会自动混入模块A，下面的代码验证了这一点。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">A</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">B</span></span></span><br><span class="line">    <span class="keyword">include</span> A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">C</span></span></span><br><span class="line">    <span class="keyword">include</span> B</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts C.included_modules  <span class="comment"># 输出: [B, A, Kernel]</span></span><br></pre></td></tr></table></figure>

<p>但是存在一个问题，比如下面的代码，A模块中定义了类方法<code>method_injected_by_a()</code>，在模块B的回调函数<code>self.included(base)</code>中调用了模块A中的方法，到目前为止没有任何问题，但是当C类include模块B时，出现了异常”undefined method ‘method_injected_by_a’ for C:Class (NoMethodError)”。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">A</span></span></span><br><span class="line">  def <span class="keyword">self</span>.included(base)</span><br><span class="line">    base.extend ClassMethods</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">ClassMethods</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_injected_by_a</span></span></span><br><span class="line">      puts <span class="string">&#x27;method_injected_by_a&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">B</span></span></span><br><span class="line">  <span class="keyword">include</span> A</span><br><span class="line"></span><br><span class="line">  def <span class="keyword">self</span>.included(base)</span><br><span class="line">      base.method_injected_by_a</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> B</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这是因为模块B在include模块A时，直接将模块A中定义的<code>#method_injected_by_a()</code>方法include为模块B的模块方法，因此，类C中并不存在这个方法了。我们可以用如下的代码进行验证。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">A</span></span></span><br><span class="line">  def <span class="keyword">self</span>.included(base)</span><br><span class="line">    base.extend ClassMethods</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">ClassMethods</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_injected_by_a</span></span></span><br><span class="line">      puts <span class="string">&#x27;method_injected_by_a&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">B</span></span></span><br><span class="line">  <span class="keyword">include</span> A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">B::method_injected_by_a  <span class="comment"># 输出：method_injected_by_a</span></span><br></pre></td></tr></table></figure>

<p>最后一句话调用了B模块中include的A模块中定义的方法，真的调用成功了。</p>
<h2 id="ActiveSupport-Concern"><a href="#ActiveSupport-Concern" class="headerlink" title="ActiveSupport::Concern"></a>ActiveSupport::Concern</h2><p>Rails的ActiveSupport::Concern正是为了解决本文第5节和第6节的解决这个问题而产生的。而且，这个类的代码不长：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Concern</span></span></span><br><span class="line">  def <span class="keyword">self</span>.extended(base) <span class="comment">#:nodoc:</span></span><br><span class="line">    <span class="comment"># 创建实例变量@_dependencies，初始化为[]</span></span><br><span class="line">    base.instance_variable_set(<span class="string">&quot;@_dependencies&quot;</span>, [])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">append_features</span><span class="params">(base)</span></span></span><br><span class="line">    <span class="comment"># 如果base定义了@_dependencies，则把当前模块加入base类的@_dependencies</span></span><br><span class="line">    <span class="keyword">if</span> base.instance_variable_defined?(<span class="string">&quot;@_dependencies&quot;</span>)</span><br><span class="line">      base.instance_variable_get(<span class="string">&quot;@_dependencies&quot;</span>) &lt;&lt; <span class="keyword">self</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># 如果base不是self的子类直接返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> base &lt; <span class="keyword">self</span></span><br><span class="line">      <span class="comment"># 依次调用base.include方法include @_dependencies中的类</span></span><br><span class="line">      <span class="variable">@_dependencies</span>.each &#123; <span class="params">|dep|</span> base.send(<span class="symbol">:include</span>, dep) &#125;</span><br><span class="line">      <span class="comment"># 调用父类的append_features()，真正的执行mixin</span></span><br><span class="line">      <span class="keyword">super</span></span><br><span class="line">      <span class="comment"># 调用base.extend, 将ClassMethods中定义的方法extend为base的类方法</span></span><br><span class="line">      base.extend const_get(<span class="string">&quot;ClassMethods&quot;</span>) <span class="keyword">if</span> const_defined?(<span class="string">&quot;ClassMethods&quot;</span>)</span><br><span class="line">      <span class="comment"># 同时将直接执行@_included_block中的代码，在base的类上下文中</span></span><br><span class="line">      base.class_eval(&amp;amp;<span class="variable">@_included_block</span>) <span class="keyword">if</span> instance_variable_defined?(<span class="string">&quot;@_included_block&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># <span class="doctag">NOTE:</span> 和self.included()不一样</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">included</span><span class="params">(base = <span class="literal">nil</span>, &amp;amp;block)</span></span></span><br><span class="line">    <span class="keyword">if</span> base.<span class="literal">nil</span>?</span><br><span class="line">      <span class="variable">@_included_block</span> = block</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">super</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码和注释中可以看出：</p>
<ul>
<li>Concern中定义的<code>self.extended()</code>告诉我们，必须通过extend混入，而不是include；</li>
<li>声明类方法的模块的名字为ClassMethods，如果拼写错误，会直接被忽略；</li>
<li>Concern类为每个通过extend混入它的类提供了一个included类方法(Class Macro)，可以传入一个块(Block)，从而实现回调。</li>
</ul>
<p>示例如下，首先需要导入active_support/concern(默认本文的读者以及安装了rails，如果没安装，请再控制台执行<code>sudo gem install rails</code>安装Rails)。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;active_support/concern&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">A</span></span></span><br><span class="line">  extend ActiveSupport::Concern</span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">ClassMethods</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_injected_by_a</span></span></span><br><span class="line">      puts <span class="string">&#x27;method_injected_by_a&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">B</span></span></span><br><span class="line">  <span class="keyword">include</span> A</span><br><span class="line">  extend ActiveSupport::Concern</span><br><span class="line">  included <span class="keyword">do</span></span><br><span class="line">    puts <span class="string">&#x27;include callback in B&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> B</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">C.method_injected_by_a</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出为：</p>
<pre><code>include callback in B
method_injected_by_a
</code></pre>
<p>我们发现：</p>
<ul>
<li>没有手动的为模块A定义<code>self.included(base)</code>也实现了将A::ClassMethods混入为C类的类方法，代码变干净了；</li>
<li>对于仍然有需要includ回调的需求，可以直接使用ActiveSupport::Concern中定义的included方法来满足；</li>
<li>在模块A中定义的方法<code>method_injected_by_a()</code>没有变成模块B的模块方法，而仍然是C类的类方法，依赖问题也被解决了。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ruby中类模型和传统的面向对象语言C++、Java、C#不同，不过看起来和JavaScript到有半分相似。令人动心的是Ruby本身提供了很强大的元编程(Meta Programming，在Java里面叫反射？)、以及Mixin这样的特性，让实现更加方便、代码更加简洁。Ruby中的模块听起来和Java中的包相似，看起来和抽象类相似，但是实际上完全不同，倒是和C中的宏比较相似。</p>
<p>Ruby中的混入有两种方式：include和extend，前者将模块中的实例方法混入为目标模块或类的实例方法，后者将模块中的实例方法混入为目标模块或类的类方法。模块的模块方法会在混入时被忽略。ruby的Module类分别提供了<code>self.included()</code>和<code>self.extended()</code>两种回调方法，不论使用哪一种混入方式，都是通过Module类的<code>append_features()</code>实现真正的混入的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://ruby-doc.org/core-1.9.3/Module.html">Ruby Module Doc</a></li>
<li><a target="_blank" rel="noopener" href="http://book.douban.com/subject/4086938/">Metaprogramming Ruby: Program Like the Ruby Pros</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.jayfields.com/2006/12/ruby-instance-and-class-methods-from.html">Jay Fields’ Thoughts: Ruby: instance and class methods from a module</a></li>
<li><a target="_blank" rel="noopener" href="http://juixe.com/techknow/index.php/2006/06/15/mixins-in-ruby/">Ruby Mixin Tutorial</a></li>
<li><a target="_blank" rel="noopener" href="http://www.devalot.com/articles/2008/09/ruby-singleton">Understanding Ruby Singleton Classes - Devalot</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2012/08/01/rails-rack/">prev</a><a class="next" href="/2012/07/08/javascript-this/">next</a></div><div class="copyright"><p>&copy; 2012 - 2021 <a href="https://zh-liang-cn.github.io">Liang</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>