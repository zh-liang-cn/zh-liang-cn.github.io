<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>JavaScript中的this | 周亮的博客</title><meta name="description" content="JavaScript中的this - Liang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="周亮的博客"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="周亮的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="周亮的博客">周亮的博客</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/zh-liang-cn/" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript中的this</h1><div class="post-info"><a></a>2012-07-08</div><div class="post-content"><p>JavaScript是一门极为灵活的语言，其神奇之处在于其面向对象的实现方式和函数。而函数往往又认为是JavaScript中最Amazing（或者翻译为惊艳？）的地方。<a target="_blank" rel="noopener" href="http://www.jquery.com">JQuery</a>这样强大的库正是建立于JavaScript灵活的函数之上的。而要正确的使用JavaScript也必须对对象和函数有更深入的了解，笔者在开发JQuery插件的过程中，遇到了很多疑惑，进而得到了一些关于对象和函数的心得，希望能对读者有用。</p>
<h2 id="JavaScript中的对象"><a href="#JavaScript中的对象" class="headerlink" title="JavaScript中的对象"></a>JavaScript中的对象</h2><h3 id="声明类和创建对象"><a href="#声明类和创建对象" class="headerlink" title="声明类和创建对象"></a>声明类和创建对象</h3><p>JavaScript是一门纯粹的面向的语言，所有的对象都继承自全局类<code>Object</code>，创建类的方式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来是声明了一个函数，实际上是定义了类的构造函数，用<code>new</code>运算符即可创建该类的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<p>创建一个对象除了上面方法外，还有下面简单方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">    name = <span class="string">&#x27;my name&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这种方式如下的代码实现了相同的作用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">me.name = <span class="string">&#x27;my name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="点（-）运算符"><a href="#点（-）运算符" class="headerlink" title="点（.）运算符"></a>点（.）运算符</h3><p>点（<code>.</code>）号在JavaScript中是一个运算符，运算符左边是一个对象，右边是一个标识符（即对象的属性名称），因为对象的属性仍然可以是对象，因此在JQuery中常见的<code>$.fn.jqModel</code>这样的字符串就表示了JQuery对象<code>$</code>的<code>fn</code>属性的<code>jqModel</code>属性，JQuery使用这样的方式来定义名称空间，避免变量名称的冲突。</p>
<p>另外，如果对象中没有指定的属性，JavaScript不会把这个当成一个错误，而只是返回很普通的<code>undefined</code>作为表达式的值，因此我们如果需要声明<code>a.b.c</code>这样的名称空间则需要按如下方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a.b = &#123;&#125;;</span><br><span class="line">a.b.c = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.b.c); <span class="comment">//输出：&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>当我们不需要这个名称空间时，可以使用<code>delete</code>运算符依次删除对象的属性。</p>
<h2 id="Global全局对象"><a href="#Global全局对象" class="headerlink" title="Global全局对象"></a>Global全局对象</h2><p>JavaScript中定义了全局对象，和<code>Object</code>、<code>Function</code>这些抽象的类不同，全局对象不是一个类，而是一个对象实例，所有的全局变量都是这个全局对象的属性。<code>Object</code>、<code>Function</code>、<code>Date</code>等核心类也定义在全局对象中。<strong>所有直接定义的函数都是全局对象的方法</strong>。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zhlwish&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello, &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<a target="_blank" rel="noopener" href="http://www.jslint.com">JSLint</a>.中，可以看到以上代码定义了两个全局属性：</p>
<pre><code>global
    name, sayHello
</code></pre>
<p>另外，如果使用隐式声明变量的方式声明变量(即不使用<code>var</code>关键字声明变量)，那么这个变量会被声明为全局变量，比如下面代码，在函数<code>sayHello()</code>中隐式声明了<code>name</code>变量，该变量被声明为全局变量，因此在调用了<code>sayHello()</code>方法后，即使在<code>sayHello()</code>方法外仍然能够获得<code>name</code>变量的值。关于<code>var</code>关键字详见：<a target="_blank" rel="noopener" href="http://coolshell.cn/articles/7480.html">Javascript 中的 var</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    firstName = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> lastName = <span class="string">&quot;Baul&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">sayHello();</span><br><span class="line"><span class="built_in">console</span>.log(firstName); <span class="comment">//&quot;Jack&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(lastName); <span class="comment">//ReferenceError: lastName is not defined.</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><p>之前有提到JavaScript是一门纯粹的面向对象的编程语言，因此在JavaScript中函数本身也是一个对象，正如在Java中类本身也是一个类一样，因此，函数对象可以被赋值给其他变量，函数通过括号运算符(<code>()</code>)进行调用。但是JavaScript中并没有class关键字。函数承担了定义类和函数本身两种角色，这也导致了本文的主题，因为在分别担任这两种角色的时候，其函数体中的<code>this</code>表现并不一样。</p>
<h3 id="独立的函数"><a href="#独立的函数" class="headerlink" title="独立的函数"></a>独立的函数</h3><p>独立定义的函数实际上是定义于全局对象之中，成为全局对象的一个方法，因此在该方法中，<code>this</code>关键字是全局对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.toString()); <span class="comment">// 输出: [object global]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，即使嵌套定义在函数中，只要这个函数没有绑定（Binding）任何其他对象（即不是任何其他对象的属性），那么这个函数仍然是独立的函数，其函数体内的<code>this</code>是全局对象的引用，下面的代码中，在<code>pFunc()</code>中声明了<code>cFunc()</code>，但是<code>cFunc()</code>中的this仍然是全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.toString()); <span class="comment">//输出: [object global]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用嵌套函数</span></span><br><span class="line">    cFunc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用父亲函数</span></span><br><span class="line">pFunc();</span><br></pre></td></tr></table></figure>

<h3 id="作为构造方法的函数"><a href="#作为构造方法的函数" class="headerlink" title="作为构造方法的函数"></a>作为构造方法的函数</h3><p>用函数来定义类，而这个函数就是类的构造函数，在本文之前就有叙述。因此在构造函数体内，<code>this</code>是对象本身的引用，如下面代码，<code>User()</code>是构造方法，在其函数体内<code>this</code>是<code>user</code>对象实例的引用，<code>name</code>是对象<code>user</code>的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.toString);</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">&quot;my name&quot;</span>); <span class="comment">//输出: [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(user.name); <span class="comment">//输出: my name</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>JavaScript允许定义匿名函数，如下代码所示，但是如果该匿名函数不赋值给任何变量，这个函数将永远得不到运行的机会，因为没办法调用这个匿名函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;匿名函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将匿名函数赋值给一个对象，然后通过括号运算符来调用这个匿名函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;匿名函数&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">func(); <span class="comment">//输出：匿名函数</span></span><br></pre></td></tr></table></figure>

<p>还有另外一种方法调用匿名函数，而这种方法在JQuery中非常常见，被称为<a target="_blank" rel="noopener" href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Immediately-Invoked Function Expression (IIFE)</a>，先声明一个匿名函数，然后通过括号运算符立即调用它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;匿名函数: &quot;</span> + name);</span><br><span class="line">&#125;)(<span class="string">&quot;my name&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>最后回到本文的主题，JavaScript中的<code>this</code>和其他语言中不一样，他是函数执行时当前对象的引用，即执行上下文（Execution Context）的引用。不论定义一个函数还是声明一个变量，当我们没有显示的指定该函数属于哪一个对象时，它就属于全局对象，这个函数体中的<code>this</code>就被绑定到了全局名称空间。下面的代码，首先创建<code>obj</code>对象，这是一个全局对象，接着为<code>obj</code>对象声明一个方法<code>method()</code>，因为已经明确指定了<code>method()</code>绑定到了<code>obj</code>对象中，因此在<code>method()</code>方法体内，<code>this</code>指向当前对象<code>obj</code>。而在<code>method()</code>方法体内定义的匿名方法（变量<code>count</code>所引用的方法）是独立的方法，因此在此方法体内<code>this</code>又是全局对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明并创建全局变量obj对象</span></span><br><span class="line">obj = &#123; &#125;;</span><br><span class="line"><span class="comment">//将method方法绑定到obj对象</span></span><br><span class="line">obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this是obj对象的引用</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.toString());</span><br><span class="line">    <span class="keyword">var</span> count = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//因为function是一个独立的变量</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.toString());</span><br><span class="line">    &#125;;</span><br><span class="line">    count();</span><br><span class="line">&#125;;</span><br><span class="line">obj.method();</span><br></pre></td></tr></table></figure>

<p>正是由于上述情况的出现，我们不得不常常编写如下的代码，我们在<code>method()</code>方法内将<code>this</code>赋值为<code>that</code>，在匿名函数中使用<code>that</code>引用<code>obj</code>对象本身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;&#125;;</span><br><span class="line">obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(that.toString());</span><br><span class="line">    &#125;;</span><br><span class="line">    count();</span><br><span class="line">&#125;;</span><br><span class="line">obj.method();</span><br></pre></td></tr></table></figure>

<p>有了执行上下文的概念，下面的代码为什么输出不一致也就不难理解了，因为前者是一个函数，默认被绑定到全局变量，而后者是创建一个对象，this被绑定到了该对象上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.toString());</span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">//输出：[object global]</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> a(); <span class="comment">//输出：[object Object]</span></span><br></pre></td></tr></table></figure>

<h2 id="this和var"><a href="#this和var" class="headerlink" title="this和var"></a>this和var</h2><p>在上一段代码中，因为<code>count</code>是<code>method()</code>方法内部定义的变量，因此在方法体外部无法引用，所以<code>count</code>所指向的匿名方法也没办法调用。但是如果我们希望能在<code>mothod()</code>方法外也能调用该方法，应该怎么做呢？至少我们可以将<code>count</code>变量绑定到<code>obj</code>对象，使<code>count</code>成为<code>obj</code>对象的一个属性，然后调用，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;&#125;;</span><br><span class="line">obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;invoking count&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">obj.method();</span><br><span class="line">obj.count(); <span class="comment">// 输出: invoking count</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在<code>method()</code>方法中定义的方法是obj对象的方法，只能通过<code>obj.count()</code>调用，而不能通过<code>obj.method.count()</code>调用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript这么语言对于我们学过的Java、C++等主流面向对象的语言有很大的差异，但是也为我们打开了另外一扇窗口。其<code>this</code>关键字在不同的使用场景下引用的对象不同，和JavaScript的面向对象设计有很大的关系，理解了这些知识，对于在什么情况下使用<code>this</code>也就不难掌握了，同时也需要记住，分析<code>this</code>所引用的对象要动态的看，不能仅仅靠分析静态的代码就能得出结论。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://book.douban.com/subject/10875361/">Pro Jquery</a></li>
<li><a target="_blank" rel="noopener" href="http://book.douban.com/subject/5252901/">JavaScript Patterns</a></li>
<li><a target="_blank" rel="noopener" href="http://book.douban.com/subject/1232061/">JAVASCRIPT权威指南</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2012/07/23/rails-activesupport-concern/">prev</a><a class="next" href="/2012/06/29/easymock/">next</a></div><div class="copyright"><p>&copy; 2012 - 2021 <a href="https://zh-liang-cn.github.io">Liang</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>